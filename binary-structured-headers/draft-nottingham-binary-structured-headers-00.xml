<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-best-00" category="std">

  <front>
    <title>Binary Structured HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields as ASCII strings. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP defines a set of data types that new headers can use to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/best">https://github.com/mnot/I-D/labels/best</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/best/">https://mnot.github.io/I-D/best/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/best">https://github.com/mnot/I-D/commits/gh-pages/best</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-best/">https://datatracker.ietf.org/doc/draft-nottingham-best/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those types in <xref target="types"/>, and specifies their use in HTTP/2 – specifically, in HPACK Literal Header Field Representations <xref target="RFC7541"/> – in <xref target="negotiate"/>.</t>

<t><xref target="backport"/> defines how to use Structured Headers for many existing headers when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="types" title="Binary Structured Types">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</t>

<figure><artwork><![CDATA[
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
]]></artwork></figure>

<t>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</t>

<section anchor="list" title="Lists">

<t>The List data type (type=0x1) has a payload consisting of a stream of Binary Structured Types representing zero or more members.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented by one or more Binary Structured Types, unless it cannot be represented; in these cases, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>list-members that are Items are represented as per <xref target="item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>The List data type can only be the first Binary Structured Type in a field-value; if it occurs in any other position, it is an error.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x2) has a Count field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
 Count (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented as an Item (<xref target="item"/>), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x3) has a Count field that indicates how many parameters are present, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
 Count (10)|  Parameters...
--+--------+--------+---------
]]></artwork></figure>

<t>Each parameter is represented by an 8-bit key length field KL, followed by that many bytes of the parameter-name, followed by a Binary Structured Types representing the parameter-value.</t>

<figure><artwork><![CDATA[
+--------+--------+---------
|  KL(8) | parameter-name(*) parameter-value...
+--------+--------+---------
]]></artwork></figure>

<t>The parameter-value is represented as a bare item (<xref target="item"/>).</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
</section>
<section anchor="dictionaries" title="Dictionaries">

<t>The Dictionary data type (type=0x4) has a payload consisting of a stream of members.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
  Dictionary members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the dictionary is represented by an 8-bit key length field KL, followed by that many bytes of the member-name, followed by one or more Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
+--------+--------+---------
|  KL(8) | member-name(*) member-value...
+--------+--------+---------
]]></artwork></figure>

<t>member-values that are Items are represented as per <xref target="item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If the dictionary cannot be represented, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>). In particular, dictionaries with member-names longer than 256 characters cannot be represented as Binary Structured Types.</t>

<t>The Dictionary data type can only be the first Binary Structured Type in a field-value; if it occurs in any other position, it is an error.</t>

</section>
<section anchor="item" title="Items">

<t>Items are represented using one or more Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</t>

<t>The item’s parameters, if present, are serialised as the Parameter type (<xref target="parameter"/>), which will be followed by zero or more types representing the parameter payload.</t>

<t>Bare items are never followed by a Parameter type.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x5) has a payload of 58 bits:</t>

<figure><artwork><![CDATA[
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>X - 1 bit; discard</t>
  <t>Integer - 50 bits, unsigned</t>
  <t>Pad - 6 bits</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x6) have a payload of 74 bits:</t>

<figure><artwork><![CDATA[
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>Integer - 47 bits, unsigned</t>
  <t>Fractional - 20 bits, unsigned integer</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
]]></artwork></figure>

<t>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0xa) has a payload of two bits:</t>

<figure><artwork><![CDATA[
--+
BX|
--+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. The value of X is discarded.</t>

</section>
</section>
<section anchor="TFV" title="Textual Field Values">

<t>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</t>

<t>Its payload is two bytes of padding, followed by the octets of the field value:</t>

<figure><artwork><![CDATA[
--+--------+----
XX| Field Value...
--+--------+----
]]></artwork></figure>

<t>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</t>

<t>TODO: huffman coding?</t>

</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the encoding of Binary Structured Headers defined in <xref target="types"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send Binary Structured Headers in the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; the field values encoded in the Header Block Fragment as Literal Header Field representations are Binary Structured Headers.</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and Textual Field Values (<xref target="TFV"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as Textual Field Values (<xref target="TFV"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>TODO: Accept and Content-Type media types use + in values.</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>TODO: explicitly convert Expires to an integer?</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values (<xref target="TFV"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='August' day='25' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-13.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
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
cB/k/R+B+76wtE0AAA==

-->

</rfc>

