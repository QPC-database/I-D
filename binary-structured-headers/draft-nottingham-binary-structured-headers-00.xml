<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-00" category="std">

  <front>
    <title>Binary Structured HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="headers"/>, and specifies their use in HTTP/2 – specifically, in HPACK Literal Header Field Representations <xref target="RFC7541"/> – in <xref target="negotiate"/>.</t>

<t><xref target="backport"/> defines how to use Structured Headers for many existing headers when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="headers" title="Binary Structured Headers">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>The types permissable as the top-level of Structured Header field values – Dictionary, List, and Item – are defined in terms of a Binary Literal Representation (<xref target="binlit"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541"/>.</t>

<t>Binary representations of the remaining types are defined in <xref target="leaf"/>.</t>

<section anchor="binlit" title="The Binary Literal Representation">

<t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame"/>).</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   Type (4)    | PLength (4+)  |
+---+---------------------------+
| Payload Data (Length octets)  |
+-------------------------------+
]]></artwork></figure>

<t>A binary literal representation contains the following fields:</t>

<t><list style="symbols">
  <t>Type:** Four bits indicating the type of the payload.</t>
  <t>PLength: The number of octets used to represent the payload, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 4-bit prefix.</t>
  <t>Payload Data: The payload, as zero or more Binary Structured Types.</t>
</list></t>

<t>The following payload types are defined:</t>

<section anchor="lists" title="Lists">

<t>List values (type=0x1) have a payload consisting of a stream of Binary Structured Types representing the members of the list.</t>

<t>list-members that are Items are represented as per <xref target="inner-item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="dictionaries" title="Dictionaries">

<t>Dictionary values (type=0x2) have a payload consisting of a stream of members.</t>

<t>Each member is represented by a key length, followed by that many bytes of the member-name, followed by one or more Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  member-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| member-value
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the member-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>member-name: KL octets of the member-name</t>
  <t>member-value: One or more Binary Structure Types</t>
</list></t>

<t>member-values that are Items are represented as per <xref target="inner-item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="items" title="Items">

<t>Item values (type=0x3) have a payload consisting of one or two Binary Structured Types, as described in <xref target="inner-item"/>.</t>

</section>
<section anchor="literal" title="String Literals">

<t>String Literals (type=0x4) are the string value of a header field; they are used to carry header field values that are not Binary Structured Headers, and may not be Structured Headers at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541"/>, Section 5.2.</t>

<t>Their payload is the octets of the field value.</t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
</section>
<section anchor="leaf" title="Binary Structured Types">

<t>Every Binary Structured Type starts with a 5-bit type field that identifies the format of its payload:</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
      Type (5)      |  Payload...
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Some Binary Structured Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x1) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Members (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the members, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Members: L octets</t>
</list></t>

<t>Each member of the list will be represented as an Item (<xref target="inner-item"/>); if any member cannot, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>The inner list’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the inner list.</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x2) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Parameters (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Parameters: L octets</t>
</list></t>

<t>Each parameter is represented by key length, followed by that many bytes of the parameter-name, followed by a Binary Structured Type representing the parameter-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  parameter-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| parameter-value (VL octets)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>parameter-name: KL octets of the parameter-name</t>
  <t>parameter-value: A Binary Structured type representing a bare item (<xref target="inner-item"/>)</t>
</list></t>

<t>Parameter-values are bare items; that is, they MUST NOT have parameters themselves.</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>Parameters are always associated with the Binary Structured Type that immediately preceded them. If parameters are not explicitly allowed on the preceding type, or there is no preceding type, it is an error.</t>

<t>ISSUE: use Huffman coding for parameter-name? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="inner-item" title="Item Payload Types">

<t>Individual Structured Header Items can be represented using the Binary Payload Types defined below.</t>

<t>The item’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the item.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x3) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |   X   | Length (8+)
+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  Integer (Length octets)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>X: 2 bits of padding</t>
  <t>Length: The number of octets used to represent the integer, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix</t>
  <t>Integer: Length octets</t>
</list></t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x4) have a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |   X   | ILength (8+)
+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  Integer (ILength octets)
+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  FLength (8+)
+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  Fractional (FLength octets)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>X: 2 bits of padding</t>
  <t>ILength: The number of octets used to represent the integer component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix.</t>
  <t>Integer - ILength octets</t>
  <t>FLength: The number of octets used to represent the fractional component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix.</t>
  <t>Fractional: FLength octets</t>
</list></t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x5) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  String (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the string, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>String: L octets.</t>
</list></t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x6) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Token (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Token: L octets.</t>
</list></t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Byte Sequence (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Byte Sequence: L octets.</t>
</list></t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0x8) has a payload of two bits:</t>

<figure><artwork><![CDATA[
  5   6   7
+---+---+---+
  B |   X   |
+---+---+---+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. X is padding.</t>

</section>
</section>
</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the Binary Structured Types defined in <xref target="headers"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit"/>.</t>

<t>Fields that are Structured Headers can have their values represented using the Binary Literal Representation corresponding to that header’s top-level type – List, Dictionary, or Item; their values will then be serialised as a stream of Binary Structured Types.</t>

<t>Additionally, any field (including those defined as Structured Headers) can be serialised as a String Literal (<xref target="literal"/>), which accommodates headers that are not defined as Structured Headers, not valid Structured Headers, or that the sending implementation does not wish to send as Binary Structured Types for some other reason.</t>

<t>Note that Field Names are always serialised as String Literals (<xref target="literal"/>).</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and String Literals (<xref target="literal"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as String Literals (<xref target="literal"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<t>ISSUE: using separate names assures that the different syntax doesn’t “leak” into normal headers, but it isn’t strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn’t understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>ISSUE: todo</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of String Literals (<xref target="literal"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='October' day='31' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-14' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-14.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
H4sIALDSu10AA9U8a3fbNpbf+Suw8ofIqSg/4sSJvGnXie3GU7/Wj5n27NmT
A5GQxDFFagnQssZNf/veB8CXJL+SOU0741YkQOC+cF+4gO/7nolMrHriQ5TI
bCYuTJYHJs9UKD5dXp6JT0qGKtOe7PczddPzwjRI5Bj6h5kcGD9JjYmS4UiO
/T4N4OtiAH/E3/rr614oDXxzt7d7uf/FC+BhmGazntAm9LxokvUEfKXN5vr6
u/VNT2ZK9sTPKlGZjL1pml0PszSf9LxrNYOnsCcOE6OyRBl/D6HwPG1kEn6W
cZrALDOlvUnUE/9j0qAj4F9REqrEdIROM5OpgYZfs7H9YbIogKYgHU+k/TGG
ztAUJXGUqP/1PJmbUZr1POF7Av6JEt0Tx11xUqBOr5kqxzK7brak2VAm0b+k
idKkJw6kNvGMGtRYRnFPjIGI/4X/6gJG1JBnAP7ImInura1Np9Oua13zvCTN
xjDUjQKAxPnBx82NjXc9IGIyKBs8z/d9IfuAHSDleZejSAs9UUE0iAKCQ4Rq
ANhpIQXzTWiVRTKONDeng5okMCMFTEFS0RFI6qGYRmYEIyTATRPxh2MVjABb
PabOkdEi1wpoRt+tbXbFoYGPdVoAMEqnwCPqtWTGsUxmQt1GGokqrFAJQNCM
VKb6M9Hqy+B6AsyF9ha+HWPrdKQSofMJNsCI0M9MUzFR8HHXUgioqj6f4L9M
+vncSrr3Eqgq9vcOL0/Pe2ISKwmgZWqc3igYGwmpAkK1rwA6JSZ5P7ZUfYmk
Bmy1zgEzIKYhBOgrWi8ikPgdvM2TUEgj/tNxeQikzPtdEL81ZPbaob+3Fsu+
ivXa0oX1Y5fnG6cwUaYCkFvRTgdGJR2RJwSXHqlw1c4NQFRnJJmy00YpTbh0
pjWc6pxnQP4OUXIAd0RRPYwILioQhbXhyJ9I+PZ+lC6UYhEBTjLoL7QI8izD
2WGlm1yjQGHr4f7lgQDdIlHQr1UGgmm8ApRKQzdSZtCFlbgGCmzt8bqLEEdR
GUdhGCvPW0Hdk6VhTjLgeaQkx0prxEsQ8cVEag3ggc4ajkBablCNgcoBUo1J
boM4cioG1NhYhZHMIoXaSGXQGX6ANgPR7btvYDUqGYxY5oHYE5mBTGKnSZYG
imZTUWbXBjUA3lEMvweRikPdFaQCMjVREhmGA+BiamNXBjpTfk0FrAoZhiDE
0D8JZjRmkCY6B1zFx7OrjkD1PJwxrCkuRRhCp3kG8CATl2sPcXf3HyAVxBIf
edWPtKV3yYEvXwCuAX4mgSwGSYDsFGY2UZqpkKhpoQ1wXYGUAR8VahN1O8lK
smhQtImJAkeGp2pCUP9A7gI0kr67Ozv1ly+WXTyocpPW1B5yrpg1jmcdajrb
/fiLOIoMyQdTSRwgv8S5QvhBSAgGjRQDpbT9emsD6AJjEQBO7QKtgOB3d04L
QpevVa73607UOZMsGiOxhinATjSaIywqCJgcZswDVYgcqNEMpyGiwUIB80wi
GYASQ8nXbIsRTsMqwKhbk8MsWY0oi01UV+yifk6TsAAuIhEaA9mBvNMoQ+2L
lrIj+rlhSYIuoAxA6UzlTMNqNjBMgvIf4UwwhhsIRSuR/RjGyHFegc6JQLOH
lmCYySSPZbEOEREUw5pdJOOzsoJOgrSjf0yTG0ALOc3EBT8HR4bl1zq+urhs
dfi/4uSUfp/v//fV4fn+Hv6++LR7dFT8cD0uPp1eHe2Vv/i9B19+PD0+3j/Z
44/hrWi8Ot79rcUC3To9uzw8Pdk9arG2RRuWBjl6R461fcUqDLAkM6C9UOkg
i/rwAN98+HgmNras8KKfApLJD283trfgAcXMKpAkntlHYDmomwloqgwHAb7B
6p5EBkwCioenQagTgaafKLnIcbVSfLfi1qhzgazlfmDJs81esGTEJWkf/jzk
VfgYVWbXDOuuCah88BBIiqRmCU8nfgx2Il4o1KzDxY2M0auA1b8XERoAeAfU
hzZMwkPDfg/ypgIhWhiyINJRymmcupIRbdAg6POC/ljtAC8iMDi0dmDdxTJQ
xPgKaXAxLxmKCFMoLMDezpw11BrpDXKuZJTgeEyhBgZ3d+CDDWgcXDhIyfsx
uVuxiDDZ7+/8TBTrMlDg2hEXVsZedzc7NJY1BB8OTz7t7+7tn1+IQSbRigLB
6RfQG1D7448/wKFfB+9/A/424e8V/G3B32v4ewN/294P4Inc++f9Dv1QSEV7
axUjid/F2ZFKhuCmt7d+gDe/F2Ms+wfHOJOzOAUVvYcWt20HSAOjjC7GuO+f
Hwgbb9ctr9jSsKHBQU0bYDyvgUEax+kUKc4uC0QxLwmV3suX4gD8ChjMoOkN
yb6gsNgl5cRowlB34TuLdI+EJcnHfVhF0ItRQI6EbJksONXP0bEJ0pDUGa7V
pezd6Lj4Zwv8R3DKIKKMbmn2CvkYhGJsGPNfKksFWl40GfPKi1SMVRglTewA
8wukh2tihdQAGA/8j1MUbez7fv12Y1WMJMQushgE/Thr8EkvgKZScoy/l4BT
UsrRfayQpsUKxjgAYMb/+K6JLCtCekg+LP4qhqlSN0rAkfRBQsZfvuyIxUNw
H2x7cCDsRLriEFAD34bHQgcRTXy/9i0ZG4FooVdQallB1hb6OrvA08imToAV
bEWb1zCxotDO4At6Xqmrm3zZfAJfLEFgin2MAyxOka4RArw0Sa5DTMLfseJj
/TckJTl7/ZlRBeN4JB+TF/X+KTjSDwjpMqnwCdHHqTTx1SrvgT/QZr8cifbb
H0gdLvgHNGaFCKINva2m+/q5v1qhA/RVmj7c3+pd8J8BGZBMiJxZneKyIZX6
y9GTtGJNQJ6sGd9WNCPMXRmsJwpCL5DFsi/h3ROn94gjS6PnVb94rvpZMsZf
Sf8QvjA9uoMNlfPqAZVjFz3GekvWPFmwmpNfp6ADog4ouuIOUEoN1NocdOCx
UFwxolgbuzAxSBeOKq7wjo0RoLMT2kBmAO1ogb9c8BDJvzRWYBd6LGfCcmlB
OIHjxDGEhhBI5MGo08wuWOilsV78cu9R3+s2svGHkR2TIvaQ6qulgiQK28XF
1X6PfM1P+WAwpnRICBD8dH9mjlOVa6/WX//osXu9TNkDB9ELh077EMHPlvTD
/FwGQNr1/5rWPzlpDC+H25iOL3IlNhxHvNDBs0j3vhPzwUaCXerXq4XJsC5e
t9v9+ilIZ3sX6Xi5pbWeMhAnRKaSK7wDkpeQYJK2wCRZtRlXxfoOpoWjCaUb
uVs0TFJeZCBgvEQKxYHrmD1J4HZFm7EzWjaXmbi6k6krisUmaJm3BTP/PYxj
Jh21X1GEI8SxdR/bzzPlzJBDM2c6n2M59TOs5qu61bTo9IRDp+4FVlxwGCCO
GzaGDEfC2YF2XVmv7ohogZFaapXc6E+0SrQlQsKDML7QpXeCKfCBsKB2SH9W
xsbkTyUEOnNfWcm7uyvGIVTIJoQpKXAUO5zGNGJD91iC44S/GB1lvxyYoa80
zov+5vck+hVI/1zpN+k1JvO+VvZLfObEv2DSgjjoiVFQMdSCQEgus3Rz0U85
yl8tAKrj//3FQA3KivbfHw/gtw+JmtLytVFRfbwFgVG9Q+0LGx7tLhBSMyek
UvQpmFlkCjzvrD4ou7PFB3rHbZXYDL3bkOCIolTptP+uVXxDjsVhAwP9xEDo
mSanogYRAbuxU9ltIk6Y0TKPy+I6pr1Zo+IZcitQyGVErysAr0l9DkRK3U7i
KIgM9JdWg6RsDPhzl+LuCM4xI21x62muOeLd+kSoLEuz+/x7SjHXBeRJLr+L
GIukpfP2K9IB0ydhdBOFuAs3vz3BAbatbKgq4lw71WipXJ/DpdD7Ckjl/AQY
6/vwEAAQ6xvQlr8aUm0IO8L0tMAVePUnuwIXqMzFr6TUXdofFP/ThvkWCrug
UWPz4JHaeoH3cdETGmIXDG12AD5cNmpI5U4dABUeJ6mO8BH6/toDyCkGSgcu
JkIH5ul7AhGj8Qwdv1nX8ZYePVGjh5OvAxAWY6WLfi+Qra253M2fKFyH34l0
HT5VvL7J9AdPwf4bTYmFfFwt0D74jtbU4fMXFZVHpAnp9a9aXt1yfQlf1EUC
mg6eAeKgJPe3hLLkYk8cLNQE7NdYVWCdnHld8Pp7CjktlH9uuMkJ46+MN5FF
jE0ZbH6z3Cqx9xKjYvSuKDy22QV6uYDLb74nLjOQf/2cAvKYcPl3sfjDzMDK
Vf+XA5jKLuTauwWc3v6eOF0H9s/lOGZpwOFnWL4B52u41STAMi9NYyVdGZ59
WsCwt02GYdQwTclAzrOrTjlo+VC6Uo02JtsAeoD5XeewmCNheD6QsVaUs6Xm
jUbzZZarLoyKhpsNNOKFJXJXFIgtL5Qr61TvVsqqUs/7B5aB9lMgJZV+YjAr
cS8isaS2FaILij9tkgCDQiOvwWsNb2Ri5NAW64CHe52k01iFQyokLGK6ogKV
+tAY2NEWGy4AvZ2yIwGzYkGdi+vHuDuiRLUolvIChAYAozIT2RLqMNIBFqVa
LCxKHLtKRxetqFa8XvZlX7oK4ADLOBdtjFXILLn4i6WpNpgtBesu2YRzY1xY
QO5W3Oyet2vxwfcOfkwL3AMJECFAsvEJgSXYwprav7w8PPn54vOHw5Pd898+
X1yeX328vDrf3/vsitna67eXp3unq/aAQHSDIz3iu0GWjnEBKUzgclGX3a2F
BbTR5bIpbLQY6XvSNY2SzKIyu+ttVgaiXFKlYH5BSZ7US5jyqitoMUgRptPE
FubYevgM3imuII6jazVFwSpXBogxqS2ip6nBYjJQNZSIoDMr4BenolkjGA3K
j4BrzKBVzB9JzmFEdtcnp71APAcl2qo77HaeXDtdLbB/cokr8H+rSeuCGiWi
WM1rLYKbAmi+G0cS9f8Bt7Tv7iS/gXGZLLxfmaSJb1sIeWIYKCM8fpHNbAoJ
xpV5bMrigUcIIyrbrjjgmm4gGThptE0PMy+g0zgajgzXdRrs4sS3tvjwdIKx
tXxF2WopcAekBu5WWMKsqrXLAU2LG9NtmZvqOpgrtS+1QYfOSyQh7+bRz6as
89S8pV0u3oXwUae+wsSDJh3X2GpRtxDQYLYTbWH9U5eCsyZ6vWqi33Q3V62N
xpITdRuoCTbs4OE6o9ieltnDb1GJGxHDakrkMeO5imggkBXOop5kgWAgxSlJ
U91evz8lugSIIM3gEQJPTgqnPC0vuxe6UjBOZPZ9WwderQxPOTO7UweGFQ/Z
9fms+oOFoF00Nu5UREyHf2Y2X9+OkiDOGVw6L1NZ3/OkWnX54qck9l1VOpmu
cRqSxag5DC4Rf+/cHeoC9IjCha2Um5c2rlTMgQhMJZWHWxlxCh/U24gdGDrN
stQ+oUbQWOHhTkpJnSZATTx8yLPxwZ8TNkPlnkWdPnOlU3Nb7RGeX5GJo8ec
jXN0J2eFDvcA9LJudnDb07Y7aa2XVKXVIq0lRf03MovSfBH9i0qyJLwfIVEo
fjtVkOZ03ARLjABbOjeTaUWCKB6D5hw1AFNnnck2WeCd+NXQXs7erji0J2QC
sE1seW0tGptTim64kBDtltuMVg250hWvuKhUKHZeatVtRdXZvKOLZhgXoD3C
YdyWWztM6QBTRCIYQ3+cpDJjVuw4kYMxJ+SWmGyRFxXIZZbgM3v+p6T2I2T3
oEZr3OgxaaaKWJhPy9UOwoWzRI6jACIM5/qnuSkC+NLrkjG24FlMazSXLlO2
7NyNGYRWHqiEBX/FiLq2cKtYgkQ3HLjj3d9QDsfRbbkZqElAizCqA+pqYvWM
7ZFBiBplJBjFgmKr3gVnSaekwlyxIR6dmlujSMBKuLwE4R37UVKonco3RZGl
O6v42HCSDPu+O1No7ebdSiGhYESSRrEmLtcJoAQijYYFSUaHXEur0Nh0RBuQ
lcYR9eUwzWDisX6808oHNxsWaBleXfEpneJh3g5XkLhiKZ2KFLyXMaJLhzuL
o47k1VtFpG4n6FTeqG7jLFqlGHJQ8TDYp9c5DQjSFyjnkoQgGIFxQSfbWvrE
zjTGs3Ph0kUKisdGe3i2DnzpigjwBIXvbT3XPZoQwDivODIFVy04zQMrdNC3
KlyLfaOSyYv0ybfgsSNTziA4ktZdj9Itqztey90g8tepXppWp7bLT79wmC2s
c7ATzVdV48YKBywIpPOCF1TyPVT58FLsBuhNC3YJi2d/35m5ZsORTIY5Zmaa
DWfS4JnzxttzPv1fe621D7bYZGns76IA+B8BNV7L2BPd0GU9Ha/vH+9YgZyH
D/U6zaIhyMWyCY/lrb9LeC5uP8e8oDYPguT6MVCV4WpjI0SVIY7OTipPsfEv
boL6iysUxOL7jzIYKTelqJ75xEZ4DeSt8tR9ZlvmmVq08LbT3BcU6hVv90Fd
BaZ8PkizqcxCgtAO+AlvnSg6NGl/lsnhWDYBP8vUgHbpFrzFlKy/O5nEEc1S
63GuTDbzdweGt/iwXkW00e8JQKNIwyUkq7h9k4P7MoTAYBnpLvdLDC7tHQnV
F4kGUBYslr+jHiiefvWrZPNPJ+y9WewrzkFhnEMVG+nz0XTNmRvQHFW8yuSj
CndgoVfbrGrgKnBO1aHG8zEEYlORKPZx0dSwg1e6vmQK6gBgOPLksyXNPM3d
ijMVz9T+VeUGwlNRi6PSWqE9K6wpoYLKspKrYv2OFxZYjJwuh7Hz2DQUrvUf
KjYQrxKiXe8KxOiPAo3UrUQHnT36PSQ2YdZwXTI86ldlSe34dDNMYvbRhUi8
U7BHdyNd5OAIrr8RJ+mN2Hj3bkusv+1tveu92hY/H1+W2ylFtp+OQqkBeLNY
3R/PFtR8u432crOFhEAUUogpWMTsKoluhZqkAHJ7fb1H/xdXlx/RHd0Qf5NJ
jtK/8W57HXyfKAFTGis5ceOsYsCRa1vDxxQTso/35UzTPJ4zY8DpNmby+HDw
6iK2S7eLcvHJZ/Jsv91a397c2N629ZzWywydb1KdgC0xVY65eoMEVVd5nMi6
Pq7vk4w1e2NaD3K+yONbWe5SadTOdfD2h8tHJOrW+KN0Up7rqCR+dc0Toc0q
d91I6eAsvqyplvSqXCyy6m45KgYYdwEDzut25k6XNDLa6PGXQXyeVHO3buAB
W5byCCldpcPhOmVDYRmmTqHpfMx5AFuTYZ1lW9NnFQyF4RPZj4C8M3dktuLk
2kuLyGZUth4atwCU/emiEjGVMwQKtFGF5Qtd7Op+Mm3JKCxDBObaKEtrukSm
4GkYDcj8AeNnoOBvKfBOXhjRglV23WKdR9d+uRyA5rtLqEoUO/ItZrAKilw4
yn4zt2AzSi6KrzCHvd7AVkXS5S9D3sjhBLfd/auyQKcDMy0OvDmIK5sQyIfu
I3fPt3/kQtSr8yPdNCVVK9KeyCirVO9G2RKeaVssVz0DuKBAFXMUS6NYToJp
iM8yK5yVI3lOrZPHXbhWqU3H+wL0VvMtbn7XOlQazskByvi9fWhYIFlXmu7j
Uk8Wb0TLEd1+TFQfpGmLdefl6elej88LYWaDK446FMxgmlLx4QqDV1cNx1T4
hIuR/Nm+MqZxsY0rVaC9k5/sEXhcUN8TIysReZWJ1fjSZpY2X9V2Kra7G/g/
DiLnTnywg7HU2jo7y1a3bm33n29tUeTIFyFpwV/ssEcZxWXwzj5gXdzAPwZP
Fgga+hcRFnRQh8PjC268SsaLmq+w+UhikGObrcge3y+VduJSKN0LsfF6e+Pd
m9ebW+sshCgm+5dy+F2JyRyD8aeZ+UYOiw0SzijaXbUpKOgEt5MHsevSt0Uj
rWmrckQJF4pBtxBr/mFu1djzbs4GNgzHpmKPddS8eaJV5WRe2Q1ASq0eQnpa
AYBfizn1wXEKelTYhE+iJfsBOAKtHTF9/9OGq0XxT0AzQPBsnEPrNIfdA7CH
8MtD4eT6EUD1j1m0Th4Qodo3JYTwXRPAjmgNR9E/r2Or1+xFKMm1kykUD79w
+jivn1zXvXd7H9Xm27dfvnwTkbk6P7QaHJfTnNTEAIFPckFVTMU5B6IXgtej
dQY/HtD/2LXU/fRha40ue2rhqd/4fStIJ7MME9rwQibBKM3et1ZKM4DU+pim
15FaTi9u550aZXz7aP1LJt2bzTevn0E6IswRn1k1o9phGnK3qjuZmJBDfXyj
4hnXGNTv60KpjOkSTE6mgs/bsZvK5eJyCrJ2bNAdDHJBWht33o29TZCPXEu6
Elaugi7GYBJjm4DI4FvLSb3L+8pKOrmqIOqMmsxd3BNH48gSyFKUzhnSPICt
JG8XAE9oL38cBWlMm4Xl0CQk5aNXeWvfOMmofhPLZPheJf7VRceR433rH3j6
av2d+FueiM31zQ2xsd7beNvb2MK4s+UVI8Lgh3vvX22EW+G7NwqCMSnDrc1O
ZVCrMNj1rRyFcg6n4wB6E4W5fGyB5dsf6e7N3ZNddLfIK5P2xjw7o0nDFPuA
6c4zUJBz/Xap7gnT9XThJfm9tF0HpoP3/8pMwIJNTco49JnlVJLjtit4c9fN
6kwCZnXJk5bG0BWkmmiSRnWnH/x19KqmiiBK9fzU1tbg9Z7wM2anE+9DASGK
hrwCyI3H2oxIX7vrIjgoIOtEJfvsASGsVNFXKhOaob90pZaZltq1vzhFC3S+
nJDZvVGt+Wsvmpt8uHYzCvs6czvqQPVsSDrTOkps2xwKRQKpIHRENza7q3wx
mvH+H2PDlcbPWgAA

-->

</rfc>

