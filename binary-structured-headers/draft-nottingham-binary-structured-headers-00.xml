<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-00" category="std">

  <front>
    <title>Binary Structured HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of the types specified by Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those types in <xref target="types"/>, and specifies their use in HTTP/2 – specifically, in HPACK Literal Header Field Representations <xref target="RFC7541"/> – in <xref target="negotiate"/>.</t>

<t><xref target="backport"/> defines how to use Structured Headers for many existing headers when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="types" title="Binary Structured Types">

<t>This section defines a binary serialisation for each of the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</t>

<figure><artwork><![CDATA[
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
]]></artwork></figure>

<t>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</t>

<t>Senders MUST set these padding bits as well as any explicitly identified by a type as padding to 0; recipients MUST ignore their values.</t>

<t>ISSUE: byte-align all types, or only the terminal one in a header value? <eref target="https://github.com/mnot/I-D/issues/306">https://github.com/mnot/I-D/issues/306</eref></t>

<section anchor="list" title="Lists">

<t>The List data type (type=0x1) has a payload consisting of a stream of Binary Structured Types representing zero or more members.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented by one or more Binary Structured Types, unless it cannot be represented; in these cases, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>list-members that are Items are represented as per <xref target="item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>The List data type can only be the first Binary Structured Type in a field-value; if it occurs in any other position, it is an error.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x2) has a Count field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
 Count (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented as an Item (<xref target="item"/>), unless it cannot be represented; in these cases, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>The inner list’s parameters, if present, are serialised as the Parameter type (<xref target="parameter"/>), which will be followed by zero or more types representing the parameters’ payload.</t>

<t>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x3) has a Count field that indicates how many parameters are present, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
 Count (10)|  Parameters...
--+--------+--------+---------
]]></artwork></figure>

<t>Each parameter is represented by an 8-bit key length field KL, followed by that many bytes of the parameter-name, followed by a Binary Structured Types representing the parameter-value.</t>

<figure><artwork><![CDATA[
+--------+--------+---------
|  KL(8) | parameter-name(*) parameter-value...
+--------+--------+---------
]]></artwork></figure>

<t>The parameter-value is represented as a bare item (<xref target="item"/>).</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
</section>
<section anchor="dictionaries" title="Dictionaries">

<t>The Dictionary data type (type=0x4) has a payload consisting of a stream of members.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
  Dictionary members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the dictionary is represented by an 8-bit key length field KL, followed by that many bytes of the member-name, followed by one or more Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
+--------+--------+---------
|  KL(8) | member-name(*) member-value...
+--------+--------+---------
]]></artwork></figure>

<t>member-values that are Items are represented as per <xref target="item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If the dictionary cannot be represented, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>). In particular, dictionaries with member-names longer than 256 characters cannot be represented as Binary Structured Types.</t>

<t>The Dictionary data type can only be the first Binary Structured Type in a field-value; if it occurs in any other position, it is an error.</t>

</section>
<section anchor="item" title="Items">

<t>Items are represented using one or more Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</t>

<t>The item’s parameters, if present, are serialised as the Parameter type (<xref target="parameter"/>), which will be followed by zero or more types representing the parameters’ payload.</t>

<t>Bare items are never followed by a Parameter type.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x5) has a payload of 58 bits:</t>

<figure><artwork><![CDATA[
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>X - 1 bit of padding</t>
  <t>Integer - 50 bits, unsigned</t>
  <t>Pad - 6 bits</t>
</list></t>

<t>ISSUE: Should we use a varint? <eref target="https://github.com/mnot/I-D/issues/304">https://github.com/mnot/I-D/issues/304</eref>.</t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x6) have a payload of 74 bits:</t>

<figure><artwork><![CDATA[
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>Integer - 47 bits, unsigned</t>
  <t>Fractional - 20 bits, unsigned integer</t>
</list></t>

<t>ISSUE: Should we use a varint? <eref target="https://github.com/mnot/I-D/issues/304">https://github.com/mnot/I-D/issues/304</eref>.</t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
]]></artwork></figure>

<t>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer), followed by four bits of padding:</t>

<figure><artwork><![CDATA[
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0xa) has a payload of two bits:</t>

<figure><artwork><![CDATA[
--+
BX|
--+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. X is padding.</t>

</section>
</section>
<section anchor="TFV" title="Textual Field Values">

<t>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</t>

<t>Its payload is two bytes of padding, followed by the octets of the field value:</t>

<figure><artwork><![CDATA[
--+--------+----
XX| Field Value...
--+--------+----
]]></artwork></figure>

<t>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the encoding of Binary Structured Headers defined in <xref target="types"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send Binary Structured Headers in the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; any String Literal representations (<xref target="RFC7541"/>, Section 5.2) encoded in the Header Block Fragment have String Data that are Binary Structured Headers.</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and Textual Field Values (<xref target="TFV"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as Textual Field Values (<xref target="TFV"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value (<xref target="TFV"/>).</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<t>ISSUE: using separate names assures that the different syntax doesn’t “leak” into normal headers, but it isn’t strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn’t understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>ISSUE: todo</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values (<xref target="TFV"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='August' day='25' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-13.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
H4sIAKOlu10AA91c6XfbRpL/jr+il/oQKSEoUpYlmV5nVtYRa6JrRSqTvH37
8ppgk8QKBLjohiiOovztW0c3DhKUZMezmV0nzyaBPqrr+FV1dTV93/dMaCLV
FR/DWKYL0TNpFpgsVUPxqd+/Fp+UHKpUe3IwSNV91xsmQSyn0H6YypHx48SY
MB5P5NQf0AC+zgfwJ9zXb7e9oTTQ5/H4sH/y5AXwZZyki67QZuh54SztCuil
zU67/a6948lUya74QcUqlZE3T9K7cZpks653pxbwbdgVZ7FRaayMf4xUeJ42
Mh7+KqMkhlkWSnuzsCv+wyRBU8BfYTxUsWkKnaQmVSMNnxZT+8GkYQCvgmQ6
k/bDFBrDqzCOwlj9p+fJzEyStOsJ3xPwJ4x1V1y0xGW+dHrMXLmQ6d3ymyQd
yzj8uzRhEnfFqdQmWtALNZVh1BVTYOK/4V8tWBG9yFIgf2LMTHe3t+fzecu9
3fa8OEmnMNS9AoLEzenRTqfzrgtMjEfFC8/zfV/IAawOFuV5/UmohZ6pIByF
AdEhhmoEq9NCCpab0CoNZRRqfp2MhJkoYRYzlfcElRhUFYTlK2BmUpamQAmM
xTw0Exg4BiGbkMebqmACTNBTahwaLTKtgJXUb3unJc4MdNZJTtckmYPoqNWa
GacyXgj1EGrktbC6JmDdQHiqgNLGQAZ3M5A5vG/g0ym+nU9ULHQ2wxe8IjNP
xExB55ZlHDBb/XqJf5nk1xtrAN63wGxxcnzWv7rpilmkJJCWqmlyD2wi/qqA
ljpQQJ0Ss2wQWWZ/ixKA1WqdwcqAx4YWQL3IjEQgsR88zeKhkEb8qxP+GFiZ
DVqglduoA9tn/vF2JAcq0ttr7e37Fs83TWCiVAWgzmIzGRkVN0UWE116ooZb
dm4gojwjqZqdNkxowrUzbeNUNzwDyneMCgVrxyWqlxeCtgaqsD2e+DMJfZ9f
Uk8pVhFUTCL9Gy2CLE1xdgAAk2lUKHx7dtI/FQA5EvX/TqWgmMbLSSm9aIXK
jFpgoNuAa9uvhzRaOKrKNBwOI+V5GwhJaTLMSAc8j7BzqrTGdQlivphJrYE8
gLLxBLTlHtENkAhYNSW9DaLQIQ+g21QNQ5mGCkFKpdAYPgDIgeoOXB8wUiWD
Ces8MHsmU9BJbDRLk0DRbCpMrW3QC1h3GMFnsOZoqFuCkCFVMyVRYDgAGtMm
NmWiU+VXkGFLyOEQlBjax8GCxgySWGewVnF0fdsUiNrjBdOaoCnCEDrJUqAH
hbgePcTj47+AVpBIfJTVINSW34UEnp6ArhF2k8AWgyxAcVqgIi7Eap6jAdoV
aBnIUSGaqIdZWrBFA/7GJgwcGz4fIBPtIBIU7/GRPj49WTlZ0HSzVfAORZZP
F0WLJr26Pjz6UZyHhhSD2SNOUVDiRiHhoB00uUZWARrtv93tAENgLJre4S0w
CTj9+OjgD5r8UVR9HjQRbGZpOEUujROgnZizwlFEBpgcZswClesa4GeK0xDT
wELAXZMuBoBeqPKafTPSadj2jXowGcySVpiCk66uqSUOEZiTeJgTF5LuTIHt
wN55mCLsoudsikFmWIWgCaAAoM1cLjSYsYFhYlT8EGeCMdxAqFOxHEQwRobz
CgxWBPo7dAHjVMZZJHMDxIWg/lUcInmdjQ0MGqQd/SiJ72FZKGlmLsQ9ODLY
XePittdvNPlfcXlFn29O/v327ObkGD/3Ph2en+cfXIvep6vb8+PiEz/3oOfR
1cXFyeUxd4anYunRxeEvDVboxtV1/+zq8vC8wTCLzisJMoyWnGgHirELVkn4
r72h0kEaDuAL9Pl4dC06u1Z5MW4BzeQvB539XfiCamaRI44W9iuIHHBmBhCV
4iAgNzDrWWjAF6B6eBqUOhbo84mTNYFsn0z0cYPt04VD1l2/YOdoEwSyNiJa
UTE7Og8zZEt8DY4BsSeg+os19KJHSyFMsrHUHvgiQ1jD0M166mhHwliJkUyM
rmZyESVyCKHg77//7n3n05/v6H/+4/3WF5t7W+I3cc1NxWa71Wpt1bbFMbxe
MlVrmTuREAbdg78iY4hUPDYT/d76Y0CbAKIlTbJ0pAnSYOo3Q8sCKEAhQ6hO
hg4SGMewFGYA9ovB7AF5jBIDDJOADAoKYgIoGgwdAk/nRhwgLwBC5gq0Bv5l
cJtBYAabnoUIcV+QR7bsRbCZ6w50tN9jCBXOyDXzNEAYWjfD+r2MMvJsZ73e
7UmXCPSZeNRUUrkmbAFYoxm+0mmIZg6bFVJoBw801F+eD5k4htx+0977nmHj
HJAadRtDridGC3xUeEWxiX9/aD90toDbqOdOAOi3Lc6D1kjcCyk5xc/rpJwj
Lvb5u0oTXBhB3VRNB+wMUFdKurP6AXdRRKLr02q91IH07wStkPs4Y6RQeh4C
nweqII6lidx11K1ZD4bDEcYDIUXgCPnVceoVGNefOjskoeU0OOwg8AOW9q2r
Yi/+E7XdfHzsn/709LQFzMIF+JYPbNKIpGcU3eGn8ppQL2Hpj48QIEyfnt6L
+s5hDAGYH5FarB8ib0RAVKM1GDmRyg4Uw0uYwvs1WEVaTPzwiR/AN4QhkQQQ
n1NwhIbH0eAs0eRFm9gAfXEsVJomKbtBjKOBtFytS4QymcXrGhXfcSp+BAhh
ykgZxkMMQ2wIREGO4xwzjRZZzNZktAAF0WDKsM5OmxAY3dtYpa/UcyZjs9Pe
+u0fr/NMMOoOqhgrydafr+J9x1ei/BsE11RCSEUbGlATS0mT5FAdHCm5dq2t
pB8f8/60vPkkBBY54kZJFCVzBoAKPplV/GJf5Gj5xsEikFyTCivtJ/JBSsuy
fjqbocvotHd2naDf250Wgq2RYYwTlwGTKY8VO70V9tYwV1e4SyaT8wgtpmAP
8770ctVg3nyOwRTMIlkVgvvallKQ/Fl2ktMnQr3sDYDAAyILQ2kOT+xqfzxv
VtSGVk/rRVeundnlg/uY6Kt2ka9zmNVhyKpalfisfoHAkB/PNw8wVKsSsfnt
1sp4wK+XudVfJWSZZaQUA4LGKqBgpLPEEV2PLF8dSV5rliUrLGhca4h/0ADB
/I5D2klQsoaZmz9Z1Njc7uvjsM+MqkrT/nE/MywG+weYE89VY0uvCNtWrcqO
9iUmVSIE7aky0quMqdzj82O4Nb2/JIg7W5Hb/4ZZQkCGVmbCADMdzWJ6zHyR
UyxxWAs8H0BfPgEN2nm7h1ljPKJYCyJIwho1aD1ja39S9GqlDmErihdEUqsE
Gee9XlZ0zEsqQmGfUJiyFssBEmya02SWYtJszThNpzIDBWbmQjIY8P9GMOac
EDMyxrz5kvetktVy+wiKP7TbNtC3Gjh+uwzHgFBvDyhz0H0F7j7/wSVTvN7P
gDmOiM/7QwHRUPz2VeggyDoDVLHeEFgKq/xW9IQvMH7Ddb8XbcqAqjEdJzZF
B7+y5t8raPwzNO5gS+SVzZXAY7c8X7xtE/+aeVAIb3ENvtijF3m2pDdJMgCV
uaKUtKQMUmxemwPZ/d7K+hQEZ6yk6XONnPe2ONlUEfT+bkXQ330Rh0G6IKMv
kO5vXz6j993z7dDFCXGK2Mo55eWZX+r/VRSl0Ijd/VWNKFHni51llXEbiK+t
KwCOoK5WWfhLjbbsL6PCnA57bKgT6nx/RBAUEp/QxeCRGSUdN5d2RXY1W6/B
FN8753nsfoipfG0s99ow2TKiHC6XvDF4PV5sXeBsvbiNWv5gBG3Fi0L9lI1G
UzqyQ0h5rWjffs+S7Sd3KqY8P36w2196WCPggz9VwHVSJkpfFvIXSNoy5v+N
oD/iIUBP/Xem4sBtuSrPauT97gvl3dl9XtzV3csoyVJuX3jGNQrxXY1YVxQD
9ooE1z/DH1CRyiLrVOW5QT9LZaosdqqz9+bgT9IdlnuSREq6Q1H7rUbWsiak
w/PqakznffyZYirr6kbiI6pBm/dHeVLkVEaadwT0urP0up/CPhECojA/NLI7
gdoVPW7ggiww1WyrVpcy2Cpl4mh7iNMjl+k8CiNimR+IUxVF+TCpKVJJ2xba
b9WlqVj6vNHgRU3lggJ1+Mdux2RNB44NHH/xJBz563b4lhXLmQDY8IDemDwJ
UNp9rjESD9W+xKE6nWf5YbkWMyiLo/BO2f2aPdMtakSa9ZJJFWwWs1kS22M9
4vCDQWUN8DR+YZ+zurfEIaoX2EoWGXtCXWxfM1LqeDHHM2kqKiBlNMnMj2D3
EpXX/d6Oy3YHyKVA3bgjnTUOFKeHgOc0aL7b/Cpg6m2IW9qMroeFomTlcaMo
MPG8v2FFyACYzFUgWPMgkdTYHqvbYpGaOpCCX8JIEJQc3ksAjbFitQAJ3sXJ
PFLDMdUU5ECRF6M4M1hQQ4snNaRvJlxyAbPiobQ7SJ6+hzGVKNfHIMJc0zKA
GJWa0JZRDUMdYH2KXYVdEu/fpeOLVlQvVq0AsA9dMZDVoWfZLMUIt7Fs/5XB
6DnleDbqyhvcGD1LyOOGm93zDu168LmjH0sanqEEmBAg27hKcM1qm6J30u+f
Xf7Q+/Xj2eXhzS+/9vo3t0f925uT418/nRwen9z0xGb7oX91fLVliwTDexzp
Ff1GaTJF9FaYyq+gH8BEh8GKXtoVaZvSYgOoP8B2y6sw1hZstbyd0qDkqUoF
dAIILSijLJbUawT0piXIMKQYJvPYJnJtfVwKzxQXFiFAzVHJCisBlXYLsGUS
OS0mBZ+H5R1cwwqRRyKWCNoMR0UnkCALawuBXFJlCFdSwGAZ1UtgubTYVK1x
q/nZJVXlgrvPrnoBXdhd5nXOjWKhWDphIwo3BfD8MAolYuspv4H4QPITGJfZ
wmAaJ7Fv39DiSWAATFiOSVUjOD+MKwG9rdfDlb6smBgftMQpl3oByyCqpnI8
mLmGT9NwPDFc90eOxKlyxRCxWtHYdCaGDVV9OyVEeNxgBbOoay0DQ5wiaOVD
O1M2iZUCvAIYmlQ+GVNRGuAwfnwenEwdXZQ9LRl5LfHUaKAw96IJC5dOE9QD
BJPgfMlHVru6JKOtdWwjmvasf9lr7WDCETEdM6nqIVAzfPGekrV2X+9qKdOl
8snNcv1kMeZbGJOtkFUaF22LvD5GSXCHZI2p3o0ySXaSYzIHl7lfy8WWrTub
YgRr269AiysEJ39BpZZYClW1doyl7HuXOS0FFNpVSWqmbnnpNvTC5EmS6Tpp
29IYFNXzYbnIDc7OFeAhrkrxOACXS2WMqVZY3rq8hvp1rrADlprDOmKCpd7J
tbLuZ04K8JCC7AFLHBjxbJjMMMYRG527IF4U8WoIblBNC+4VkYmlBA3wPhwi
k+yITFNeW7wabCD84daTk+VFXcbmMKF60pAC1wja4ySlGdM8/iNgz70JYOck
D1RTw0hYI1hcIAcithyz4PZrtmCnFWbj+YBJ0pKhUPVypTB5uIjlNAwgzHPx
VwLBsAtXC3cnI3yDRfEWrtae/DGkcjOWEMIrsElnwEs3IipfsR8oLxN0eslz
Xhz+goo4DR8UVp2y6ZCG5rFsE3wFFibyqQ21SGFnHKakGblJMZ7C1iDSSZPu
kPD8eeHfaJmBDmrWa67dVws+PFvqw4WxXL1E3G+9KqInzDxxFd7Wlz5u5AoK
QSMgaEWb0VpnCW45Q6xWR4bRXQN7QrhaE4sRZOpKKOmUKhonKUw81a+PFbiM
fuk0cv0W9hNsNO/xrgedNrNR4Z0vkYBjmOJyqdQ+LzynYMrikHqYoS+/V62l
6uC8QjRPhJNMOZTSGQ0IuhcoFwQNQS0C4+J+e0UAu9iZpljkOlxro4A7NuDG
+lEIYUoKwBPkIY9NNBzThEDGTcmp5lK15LBv5t04jk6ZgrJqIXXk1MpVrSUh
18HJ15CxY1PGJDiWVhNEmZMXGGUKa4Rt+rBex93BMMVJdMI6ssVtLL1v3Mrq
D5t5otUyUUzocZyIRIYQ2OOFhZr6uxdrWL4VhwFGKsKnesD8u3/i3Nzyi3MZ
jzPcHS+/uJYG7/4sPb3hW1iVx1r74ItNmkT+IWqAfwRrY2PGlnhKva6lE/bz
410oUPThS62u0nAMirFuwgv54B/SOuvf32A2UpsXSXLtmKjScJWxkaLSEOfX
l6VvkfF790H1wS1qYt7/SAYT5aaEx0UVAr7k9FxZpq6bfbMq1PwNp35XelAY
nT89AbwKTPH9NEnnMh0ShXbAT3j7L2+wzPtrjGTlMuHXqRrRcV3NU8xO+Yez
WRTSLJUWN8qkC/9wZKgzlaCKTYx7AoAUabjwYAtPDzMIX8awYVnHuv5JsYK+
vatWfgD7QwCQVWP5CYEg//azX2abfzXj6M2uvhQb5L55qCIjfb4ppHnHDNBR
XleRAMKiWVl5Z7GhyH1Lur3r463nlcy3DfCK0Jd8QZWAJP3s6jj0BUsb5McN
5yy+EP/L8AbaUwLGSeGv0KPl/pTWgnBZShIwwuMFMrskh+acP12CXBtBlLwg
XvWmA+YSxRiP4s2cB4kROof0x8jtcg7cBS8pFSOVZOIqVfgq2NJGieVHF9Y5
KX1Md9d7GQSC7T1xmdyLzrt3u6J90N19132zL3646BfH5fnJAFW6qBFEs3h1
BNRstVbbniGJOHOFd6QFIldDzIPhym7j8EGoWQIkb7bbXfpf3PaPMBztiL/K
OEP177zbb0P0E8bgTCMlZ26cLdxxZK6ymzkm5AAvLs/pSH3JkYGkNzGFwrnz
rTqxS3eO0vvkM3v2D3bb+zud/X1mxaGNM4cuOilPwL6YCo54D2X42k+einHB
j2v7We6a4zGtRxlfrPxqvruADV2+dcRJaHc0g7eU/EkyK24NlVJuuhKM0CGP
u/9ZxDj11+YrmbbSTc8td988H2DaAhjkjFpz5e7SUi4Rg/5iG5/F5ayZG3jE
vqWotaRLzbxhp0QUXm5ykKazKWcCphCk0bR8US2hnapFGNqIz+QgjEKD6Tiq
Pi3Fufb6OHmNUgIYD1xmsC+mbVe5Pd0cFXO5QKIAjkoyr42yy8cnlBhXWHoG
wrXbLK2hdem4bRiOyAGC4BcA8Q+09Y6/MaIBZnbXYNCj32VwWQDNl0mpRhAb
8s9MgBnkWUiqMVzKLtj7pm4fXxIOB76BYcHQbdwxp9M5tWjPYMoi0MnIzOle
JguAKS6lf1EOrVceFu3bk/fbm3O97EvKbmRzJkNktDtrCdM1MtNb7spgUfhq
d0hLULR+I8t5MDobs8qJB2n2SNLhOsXceXCV2EyoLwC4lp9Cw2qD0osbCoFS
fm6/LLkgWUVN17kAyvyJaDim287E9VGSNGx9/tXVcZcv+mBqg+t0mrSfya+j
zqTBHxGgdGSTL0yitQyUMUs3jW1+hi8o/4XliJj9TyXI0qa8LMTyFtOmlnbe
VPLA+60O/sf7yJWSUo4w1rpb52jZ7Vbd7cmXu1tUOQpGSFvwE4fsYUo7M3hm
v2CJ3Mi/gFgW76D6vRBPgKnB2UWPX97G07rXt/j6XOI2x762KnvxvFbaiQul
dA9E5+1+593e253dNishqslJX47/qdRkRcD40Sx8I8fsw9lYXFYBAhwA6BgP
8kaRazKwdSONeaN0ZQgNxWBciEfvMLeqq7sozRZqGpsqQ9qIvFmslWnWNAOS
EotDyE+rAPCpXlIfnaSgRUlM+E005CCAQKDxXsw//KXjClf8S0AG2D4bF9E6
5LDHAMxHUVzFp9iPCKp2ZtW6fEGFKn0KCqHfMoFN0RhPwv+6iyyukU6dh/Gd
06mi5r7I7Md31fDd/kDAzsHB09NXUZnbmzOL4GhOK1oTAQU+6QXfBM+voiG/
kLwu2Rl8eAH/sWmB/dSxsY2Xv3UD75RHHxpBMlukmNFu4KlVMEnSD42Nwg0g
t46S5C6/VlTDL35PhPeU8e1XG18y6/Z29t5+AeuIMed82dRMyre9ONwqtu0Y
ZWJKHrdo0YJPd6s/ooBaGdHPEXE+FWLepj2yK4zLAWTlGp8NifJdGpbh8ZGJ
225T2cl0KrcAi3E3iZubgNjgW89JrYsfkCj45GozqDEiGafYwRuE09AyyHKU
7hnQPMs1VVpNwyCJkph+jcANTUpSfPVKT+0TpxnlPpGMxx9U7N/2mo4dHxp/
wzs77Xfir1ksdto7HdFpdzsH3c4ubjwbXj4iDH52/OFNZ7g7fLenYDcm5XB3
p1ka1AIGh76ln0FwAaeTAEYTubt8bT3Rwff0K0iHl4cYblFUJu1PmNgZTTJM
sA247iwFgFxpd0jVJ5ixp58eoriXDuzAdfAJYJEKqDnXpJTDgEVOxRDuxIKi
Ju1mdS4BE7sUSUtj6MegNPEkCatBP5Y/QlQ1V0RRolentr4Gf2gJPkYcdF7F
eKhkwjFbAIXxePId6jsql7MntIEh70Q1cxwBIa1UV1WACc0wWF/SUipuK/0A
G07RAMyXM3K796qB07xwzIfGm9K+r7m0PQGGgJKMCTRtpMTOza0hTyHlnA7p
N/Xcr6rhdsb7H7fLFk5xUAAA

-->

</rfc>

