<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Binary Structured HTTP Headers</title><script>
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          var postfix = fragid.substring(2);
          if (postfix.startsWith("abstract")) {
            window.location.hash = prefix + postfix;
          } else if (postfix.startsWith("note-")) {
            window.location.hash = prefix + "note." + postfix.substring(5);
          } else {
            window.location.hash = prefix + "section." + postfix;
          }
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><meta name="viewport" content="width=device-width, initial-scale=1"><meta property="og:type" content="article"><meta property="og:title" content="Binary Structured HTTP Headers"><meta property="og:description" content="This specification defines a binary serialisation of the types specified by Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers."><meta property="og:url" content="https://mnot.github.io/I-D/binary-structured-headers/"><meta property="og:site_name" content="mnot's Internet Drafts"><link rel="stylesheet" type="text/css" href="../Tools/style.css"><style type="text/css">
      body {
        padding-top: 80px;
        padding-bottom: 80px;
        position: relative;
      }
      .table.header th, .table.header td {
        border-top: none;
        padding: 0;
      }
      #sidebar {
        margin-top: -10px;
        height: 90%;
        overflow-y: auto;
        font-size: 90%;
      }
      #rfc\.meta {
        width: 40%;
        float: right
      }
      .toc ul {
        list-style: none;
      }
      .filename {
        color: rgb(119, 119, 119);
        font-size: 23px;
        font-weight: normal;
        height: auto;
        line-height: 23px;
      }
      dl {
        margin-left: 1em;
      }
      dl.dl-horizontal: {
        margin-left: 0;
      }
      dl > dt {
        float: left;
        margin-right: 1em;
      }
      dl.nohang > dt {
        float: none;
      }
      dl > dd {
        margin-bottom: .5em;
      }
      dl.compact > dd {
        margin-bottom: 0em;
      }
      dl > dd > dl {
        margin-top: 0.5em;
        margin-bottom: 0em;
      }
      ul.empty {
        list-style-type: none;
      }
      ul.empty li {
        margin-top: .5em;
      }
      td.reference {
        padding-right: 1em;
        vertical-align: top;
      }
      .feedback {
        position: fixed;
        bottom: 5px;
        right: 5px;
      }
      .fbbutton {
        margin-left: 5px;
      }
      h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
        color: rgb(51, 51, 51);
      }
      span.tt {
        font: 11pt consolas, monospace;
        font-size-adjust: none;
      }
    </style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="License" href="#rfc.copyrightnotice"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 Binary Structured Types" href="#rfc.section.2"><link rel="Chapter" title="3 Using Binary Structured Headers in HTTP/2" href="#rfc.section.3"><link rel="Chapter" title="4 Using Binary Structured Headers with Existing Fields" href="#rfc.section.4"><link rel="Chapter" title="5 IANA Considerations" href="#rfc.section.5"><link rel="Chapter" title="6 Security Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 Normative References" href="#rfc.section.7"><meta name="viewport" content="initial-scale=1"><meta name="generator" content="https://github.com/mnot/RFCBootstrap XSLT vendor: Saxonica http://www.saxonica.com/"><meta name="keywords" content="Internet-Draft"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Nottingham, M."><meta name="dcterms.identifier" content="urn:ietf:id:draft-nottingham-binary-structured-headers-00"><meta name="dcterms.issued" content="2019-11-01"><meta name="dcterms.abstract" content="This specification defines a binary serialisation of the types specified by Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers."><meta name="description" content="This specification defines a binary serialisation of the types specified by Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers."></head><body><div class="container" id="top"><div class="row"><div class="col-lg-4 order-last d-none d-lg-block" id="sidebar" role="navigation"><div class="navbar"><div class="navbar-brand"><a href="#top"></a></div><br clear="all"><div class=""><div class="toc "><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Binary Structured Types</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#list">Lists</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter">Parameters</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionaries">Dictionaries</a></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#item">Items</a><ul><li><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#integers">Integers</a></li><li><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#floats">Floats</a></li><li><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#token">Tokens</a></li><li><a href="#rfc.section.2.3.5">2.3.5.</a>&nbsp;&nbsp;&nbsp;<a href="#byte-sequences">Byte Sequences</a></li><li><a href="#rfc.section.2.3.6">2.3.6.</a>&nbsp;&nbsp;&nbsp;<a href="#booleans">Booleans</a></li></ul></li><li><a href="#rfc.section.2.4">2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#TFV">Textual Field Values</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#negotiate">Using Binary Structured Headers in HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">Binary Structured Headers Setting</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#frame">The BINHEADERS Frame</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#backport">Using Binary Structured Headers with Existing Fields</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#direct">Directly Represented Fields</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#aliased">Aliased Fields</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#urls">URLs</a></li><li><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dates">Dates</a></li><li><a href="#rfc.section.4.2.3">4.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#etags">ETags</a></li><li><a href="#rfc.section.4.2.4">4.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#links">Links</a></li><li><a href="#rfc.section.4.2.5">4.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#cookies">Cookies</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div></div></div></div><div class="col-lg-8 order-first main" role="main"><header><table class="table table-condensed header" id="rfc.headerblock"><tbody><tr><td class="text-left">Network Working Group</td><td class="text-right">M. Nottingham</td></tr><tr><td class="text-left">Internet-Draft</td><td class="text-right">Fastly</td></tr><tr><td class="text-left">Intended status: Standards Track</td><td class="text-right">November 1, 2019</td></tr><tr><td class="text-left">Expires: May 4, 2020</td><td class="text-right"></td></tr></tbody></table><div id="rfc.title"><h1>Binary Structured HTTP Headers</h1><div class="filename"><a href="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers" class="smpl">draft-nottingham-binary-structured-headers</a>-<a href="https://tools.ietf.org/html/draft-nottingham-binary-structured-headers-00" class="smpl">00</a></div></div></header><hr><h2 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h2><div class="lead"><div id="rfc.abstract.p.1"><p>This specification defines a binary serialisation of the types specified by Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</p></div></div><section id="rfc.note.1" class="note"><h2><a href="#rfc.note.1">Note to Readers</a></h2><div id="rfc.note.1.p.1"><p><em>RFC EDITOR: please remove this section before publication</em></p></div><div id="rfc.note.1.p.2"><p>The issues list for this draft can be found at <a href="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</a>.</p></div><div id="rfc.note.1.p.3"><p>The most recent (often, unpublished) draft is at <a href="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</a>.</p></div><div id="rfc.note.1.p.4"><p>Recent changes are listed at <a href="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</a>.</p></div><div id="rfc.note.1.p.5"><p>See also the draft’s current status in the IETF datatracker, at <a href="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</a>.</p></div></section><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><div id="rfc.boilerplate.1.p.1"><p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p></div><div id="rfc.boilerplate.1.p.2"><p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). Note that other groups may also distribute working documents as Internet-Drafts. The list of current Internet-Drafts is at <a href="http://datatracker.ietf.org/drafts/current/">http://datatracker.ietf.org/drafts/current/</a>.</p></div><div id="rfc.boilerplate.1.p.3"><p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as “work in progress”.</p></div><div id="rfc.boilerplate.1.p.4"><p>This Internet-Draft will expire on May 4, 2020.</p></div></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><div id="rfc.boilerplate.2.p.1"><p>Copyright © 2019 IETF Trust and the persons identified as the document authors. All rights reserved.</p></div><div id="rfc.boilerplate.2.p.2"><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p></div></section><div class="toc d-lg-none"><ul><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#introduction">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#notational-conventions">Notational Conventions</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#types">Binary Structured Types</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#list">Lists</a><ul><li><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#inner-list">Inner Lists</a></li><li><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#parameter">Parameters</a></li></ul></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dictionaries">Dictionaries</a></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#item">Items</a><ul><li><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#integers">Integers</a></li><li><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#floats">Floats</a></li><li><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#strings">Strings</a></li><li><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#token">Tokens</a></li><li><a href="#rfc.section.2.3.5">2.3.5.</a>&nbsp;&nbsp;&nbsp;<a href="#byte-sequences">Byte Sequences</a></li><li><a href="#rfc.section.2.3.6">2.3.6.</a>&nbsp;&nbsp;&nbsp;<a href="#booleans">Booleans</a></li></ul></li><li><a href="#rfc.section.2.4">2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#TFV">Textual Field Values</a></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#negotiate">Using Binary Structured Headers in HTTP/2</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#setting">Binary Structured Headers Setting</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#frame">The BINHEADERS Frame</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#backport">Using Binary Structured Headers with Existing Fields</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#direct">Directly Represented Fields</a></li><li><a href="#rfc.section.4.2">4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#aliased">Aliased Fields</a><ul><li><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#urls">URLs</a></li><li><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#dates">Dates</a></li><li><a href="#rfc.section.4.2.3">4.2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#etags">ETags</a></li><li><a href="#rfc.section.4.2.4">4.2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#links">Links</a></li><li><a href="#rfc.section.4.2.5">4.2.5.</a>&nbsp;&nbsp;&nbsp;<a href="#cookies">Cookies</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#iana-considerations">IANA Considerations</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#security-considerations">Security Considerations</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">Normative References</a></li><li><a href="#rfc.authors">Author's Address</a></li></ul></div><section id="introduction"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#introduction">Introduction</a></h2><div id="rfc.section.1.p.1"><p>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</p></div><div id="rfc.section.1.p.2"><p>Structured Headers for HTTP <a href="#I-D.ietf-httpbis-header-structure"><cite title="Structured Headers for HTTP">[I-D.ietf-httpbis-header-structure]</cite></a> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those types in <a href="#types" title="Binary Structured Types">Section&nbsp;2</a>, and specifies their use in HTTP/2 – specifically, in HPACK Literal Header Field Representations <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a> – in <a href="#negotiate" title="Using Binary Structured Headers in HTTP/2">Section&nbsp;3</a>.</p></div><div id="rfc.section.1.p.3"><p><a href="#backport" title="Using Binary Structured Headers with Existing Fields">Section&nbsp;4</a> defines how to use Structured Headers for many existing headers when supported by two peers.</p></div><div id="rfc.section.1.p.4"><p>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</p></div><section id="notational-conventions"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.1.p.1"><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in BCP 14 <a href="#RFC2119"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a> <a href="#RFC8174"><cite title="Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words">[RFC8174]</cite></a> when, and only when, they appear in all capitals, as shown here.</p></div></section></section><section id="types"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#types">Binary Structured Types</a></h2><div id="rfc.section.2.p.1"><p>This section defines a binary serialisation for each of the Structured Header Types defined in <a href="#I-D.ietf-httpbis-header-structure"><cite title="Structured Headers for HTTP">[I-D.ietf-httpbis-header-structure]</cite></a>.</p></div><div id="rfc.section.2.p.2" class="avoidbreakafter"><p>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</p></div><div id="rfc.figure.u.1"><div><pre>
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
</pre></div></div><div id="rfc.section.2.p.3"><p>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</p></div><div id="rfc.section.2.p.4"><p>Senders MUST set these padding bits as well as any explicitly identified by a type as padding to 0; recipients MUST ignore their values.</p></div><div id="rfc.section.2.p.5"><p>ISSUE: byte-align all types, or only the terminal one in a header value? <a href="https://github.com/mnot/I-D/issues/306">https://github.com/mnot/I-D/issues/306</a></p></div><section id="list"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#list">Lists</a></h3><div id="rfc.section.2.1.p.1"><p>The List data type (type=0x1) has a payload consisting of a stream of Binary Structured Types representing zero or more members.</p></div><div id="rfc.figure.u.2"><div><pre>
--+--------+--------+---------
  List members...
--+--------+--------+---------
</pre></div></div><div id="rfc.section.2.1.p.2"><p>Each member of the list will be represented by one or more Binary Structured Types, unless it cannot be represented; in these cases, the entire field value will be serialised as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.2.1.p.3"><p>list-members that are Items are represented as per <a href="#item" title="Items">Section&nbsp;2.3</a>; list-members that are inner-lists are represented as per <a href="#inner-list" title="Inner Lists">Section&nbsp;2.1.1</a>.</p></div><div id="rfc.section.2.1.p.4"><p>The List data type can only be the first Binary Structured Type in a field-value; if it occurs in any other position, it is an error.</p></div><section id="inner-list"><h4 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a>&nbsp;<a href="#inner-list">Inner Lists</a></h4><div id="rfc.section.2.1.1.p.1"><p>The Inner List data type (type=0x2) has a Count field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</p></div><div id="rfc.figure.u.3"><div><pre>
--+--------+--------+---------
 Count (10)|  List members...
--+--------+--------+---------
</pre></div></div><div id="rfc.section.2.1.1.p.2"><p>Each member of the list will be represented as an Item (<a href="#item" title="Items">Section&nbsp;2.3</a>), unless it cannot be represented; in these cases, the entire field value will be serialised as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.2.1.1.p.3"><p>The inner list’s parameters, if present, are serialised as the Parameter type (<a href="#parameter" title="Parameters">Section&nbsp;2.1.2</a>), which will be followed by zero or more types representing the parameters’ payload.</p></div><div id="rfc.section.2.1.1.p.4"><p>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div></section><section id="parameter"><h4 id="rfc.section.2.1.2"><a href="#rfc.section.2.1.2">2.1.2.</a>&nbsp;<a href="#parameter">Parameters</a></h4><div id="rfc.section.2.1.2.p.1"><p>The Parameters data type (type=0x3) has a Count field that indicates how many parameters are present, as an unsigned 10-bit integer.</p></div><div id="rfc.figure.u.4"><div><pre>
--+--------+--------+---------
 Count (10)|  Parameters...
--+--------+--------+---------
</pre></div></div><div id="rfc.section.2.1.2.p.2"><p>Each parameter is represented by an 8-bit key length field KL, followed by that many bytes of the parameter-name, followed by a Binary Structured Types representing the parameter-value.</p></div><div id="rfc.figure.u.5"><div><pre>
+--------+--------+---------
|  KL(8) | parameter-name(*) parameter-value...
+--------+--------+---------
</pre></div></div><div id="rfc.section.2.1.2.p.3"><p>The parameter-value is represented as a bare item (<a href="#item" title="Items">Section&nbsp;2.3</a>).</p></div><div id="rfc.section.2.1.2.p.4"><p>If the parameters cannot be represented, the entire field value will be serialised as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.2.1.2.p.5"><p>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div></section></section><section id="dictionaries"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#dictionaries">Dictionaries</a></h3><div id="rfc.section.2.2.p.1"><p>The Dictionary data type (type=0x4) has a payload consisting of a stream of members.</p></div><div id="rfc.figure.u.6"><div><pre>
--+--------+--------+---------
  Dictionary members...
--+--------+--------+---------
</pre></div></div><div id="rfc.section.2.2.p.2"><p>Each member of the dictionary is represented by an 8-bit key length field KL, followed by that many bytes of the member-name, followed by one or more Binary Structured Types representing the member-value.</p></div><div id="rfc.figure.u.7"><div><pre>
+--------+--------+---------
|  KL(8) | member-name(*) member-value...
+--------+--------+---------
</pre></div></div><div id="rfc.section.2.2.p.3"><p>member-values that are Items are represented as per <a href="#item" title="Items">Section&nbsp;2.3</a>; member-values that are inner-lists are represented as per <a href="#inner-list" title="Inner Lists">Section&nbsp;2.1.1</a>.</p></div><div id="rfc.section.2.2.p.4"><p>If the dictionary cannot be represented, the entire field value will be serialised as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>). In particular, dictionaries with member-names longer than 256 characters cannot be represented as Binary Structured Types.</p></div><div id="rfc.section.2.2.p.5"><p>The Dictionary data type can only be the first Binary Structured Type in a field-value; if it occurs in any other position, it is an error.</p></div></section><section id="item"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#item">Items</a></h3><div id="rfc.section.2.3.p.1"><p>Items are represented using one or more Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</p></div><div id="rfc.section.2.3.p.2"><p>The item’s parameters, if present, are serialised as the Parameter type (<a href="#parameter" title="Parameters">Section&nbsp;2.1.2</a>), which will be followed by zero or more types representing the parameters’ payload.</p></div><div id="rfc.section.2.3.p.3"><p>Bare items are never followed by a Parameter type.</p></div><section id="integers"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;<a href="#integers">Integers</a></h4><div id="rfc.section.2.3.1.p.1" class="avoidbreakafter"><p>The Integer data type (type=0x5) has a payload of 58 bits:</p></div><div id="rfc.figure.u.8"><div><pre>
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
</pre></div></div><div id="rfc.section.2.3.1.p.2" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.3.1.p.3"><ul><li>S - sign bit; 0 is negative, 1 is positive</li><li>X - 1 bit of padding</li><li>Integer - 50 bits, unsigned</li><li>Pad - 6 bits</li></ul></div><div id="rfc.section.2.3.1.p.4"><p>ISSUE: Should we use a varint? <a href="https://github.com/mnot/I-D/issues/304">https://github.com/mnot/I-D/issues/304</a>.</p></div></section><section id="floats"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;<a href="#floats">Floats</a></h4><div id="rfc.section.2.3.2.p.1" class="avoidbreakafter"><p>The Float data type (type=0x6) have a payload of 74 bits:</p></div><div id="rfc.figure.u.9"><div><pre>
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
</pre></div></div><div id="rfc.section.2.3.2.p.2" class="avoidbreakafter"><p>Its fields are:</p></div><div id="rfc.section.2.3.2.p.3"><ul><li>S - sign bit; 0 is negative, 1 is positive</li><li>Integer - 47 bits, unsigned</li><li>Fractional - 20 bits, unsigned integer</li></ul></div><div id="rfc.section.2.3.2.p.4"><p>ISSUE: Should we use a varint? <a href="https://github.com/mnot/I-D/issues/304">https://github.com/mnot/I-D/issues/304</a>.</p></div></section><section id="strings"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;<a href="#strings">Strings</a></h4><div id="rfc.section.2.3.3.p.1" class="avoidbreakafter"><p>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</p></div><div id="rfc.figure.u.10"><div><pre>
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
</pre></div></div><div id="rfc.section.2.3.3.p.2"><p>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.2.3.3.p.3"><p>ISSUE: use Huffman coding? <a href="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</a></p></div></section><section id="token"><h4 id="rfc.section.2.3.4"><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;<a href="#token">Tokens</a></h4><div id="rfc.section.2.3.4.p.1" class="avoidbreakafter"><p>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</p></div><div id="rfc.figure.u.11"><div><pre>
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
</pre></div></div><div id="rfc.section.2.3.4.p.2"><p>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.2.3.4.p.3"><p>ISSUE: use Huffman coding? <a href="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</a></p></div></section><section id="byte-sequences"><h4 id="rfc.section.2.3.5"><a href="#rfc.section.2.3.5">2.3.5.</a>&nbsp;<a href="#byte-sequences">Byte Sequences</a></h4><div id="rfc.section.2.3.5.p.1" class="avoidbreakafter"><p>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer), followed by four bits of padding:</p></div><div id="rfc.figure.u.12"><div><pre>
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
</pre></div></div><div id="rfc.section.2.3.5.p.2"><p>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div></section><section id="booleans"><h4 id="rfc.section.2.3.6"><a href="#rfc.section.2.3.6">2.3.6.</a>&nbsp;<a href="#booleans">Booleans</a></h4><div id="rfc.section.2.3.6.p.1" class="avoidbreakafter"><p>The Boolean data type (type=0xa) has a payload of two bits:</p></div><div id="rfc.figure.u.13"><div><pre>
--+
BX|
--+
</pre></div></div><div id="rfc.section.2.3.6.p.2"><p>If B is 0, the value is False; if B is 1, the value is True. X is padding.</p></div></section></section><section id="TFV"><h3 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a>&nbsp;<a href="#TFV">Textual Field Values</a></h3><div id="rfc.section.2.4.p.1"><p>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</p></div><div id="rfc.section.2.4.p.2" class="avoidbreakafter"><p>Its payload is two bytes of padding, followed by the octets of the field value:</p></div><div id="rfc.figure.u.14"><div><pre>
--+--------+----
XX| Field Value...
--+--------+----
</pre></div></div><div id="rfc.section.2.4.p.3"><p>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</p></div><div id="rfc.section.2.4.p.4"><p>ISSUE: use Huffman coding? <a href="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</a></p></div></section></section><section id="negotiate"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#negotiate">Using Binary Structured Headers in HTTP/2</a></h2><div id="rfc.section.3.p.1"><p>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <a href="#backport" title="Using Binary Structured Headers with Existing Fields">Section&nbsp;4</a>).</p></div><div id="rfc.section.3.p.2"><p>Peers advertise and discover this support using a HTTP/2 setting defined in <a href="#setting" title="Binary Structured Headers Setting">Section&nbsp;3.1</a>, and convey Binary Structured Headers in a frame type defined in <a href="#frame" title="The BINHEADERS Frame">Section&nbsp;3.2</a>.</p></div><section id="setting"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#setting">Binary Structured Headers Setting</a></h3><div id="rfc.section.3.1.p.1"><p>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</p></div><div id="rfc.section.3.1.p.2" class="avoidbreakafter"><p>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</p></div><div id="rfc.section.3.1.p.3"><ol><li>The peer supports the encoding of Binary Structured Headers defined in <a href="#types" title="Binary Structured Types">Section&nbsp;2</a>.</li><li>The peer will process the BINHEADERS frames as defined in <a href="#frame" title="The BINHEADERS Frame">Section&nbsp;3.2</a>.</li><li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <a href="#I-D.ietf-httpbis-header-structure"><cite title="Structured Headers for HTTP">[I-D.ietf-httpbis-header-structure]</cite></a>).</li><li>The peer will likewise transform all fields defined as Aliased Fields (<a href="#aliased" title="Aliased Fields">Section&nbsp;4.2</a>) into their non-aliased forms as necessary.</li></ol></div><div id="rfc.section.3.1.p.4"><p>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</p></div></section><section id="frame"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#frame">The BINHEADERS Frame</a></h3><div id="rfc.section.3.2.p.1"><p>When a peer has indicated that it supports this specification {#setting}, a sender can send Binary Structured Headers in the BINHEADERS Frame Type (0xTODO).</p></div><div id="rfc.section.3.2.p.2"><p>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<a href="#RFC7540"><cite title="Hypertext Transfer Protocol Version 2 (HTTP/2)">[RFC7540]</cite></a>, Section 6.2), with one exception; any String Literal representations (<a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a>, Section 5.2) encoded in the Header Block Fragment have String Data that are Binary Structured Headers.</p></div><div id="rfc.section.3.2.p.3"><p>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>) to their string counterparts.</p></div><div id="rfc.section.3.2.p.4"><p>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <a href="#backport" title="Using Binary Structured Headers with Existing Fields">Section&nbsp;4</a>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.3.2.p.5"><p>Field values are stored in the HPACK <a href="#RFC7541"><cite title="HPACK: Header Compression for HTTP/2">[RFC7541]</cite></a> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</p></div><div id="rfc.section.3.2.p.6"><p>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</p></div></section></section><section id="backport"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#backport">Using Binary Structured Headers with Existing Fields</a></h2><div id="rfc.section.4.p.1"><p>Any header field can potentially be parsed as a Structured Header according to the algorithms in <a href="#I-D.ietf-httpbis-header-structure"><cite title="Structured Headers for HTTP">[I-D.ietf-httpbis-header-structure]</cite></a> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</p></div><div id="rfc.section.4.p.2"><p>This section identifies fields that will usually succeed in <a href="#direct" title="Directly Represented Fields">Section&nbsp;4.1</a>, and those that can be mapped into Structured Headers by using an alias field name in <a href="#aliased" title="Aliased Fields">Section&nbsp;4.2</a>.</p></div><section id="direct"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#direct">Directly Represented Fields</a></h3><div id="rfc.section.4.1.p.1"><p>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <a href="#I-D.ietf-httpbis-header-structure"><cite title="Structured Headers for HTTP">[I-D.ietf-httpbis-header-structure]</cite></a>, and thus can usually be serialised using the corresponding Binary Structured Types.</p></div><div id="rfc.section.4.1.p.2"><p>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.4.1.p.3"><ul><li>Accept - List</li><li>Accept-Encoding - List</li><li>Accept-Language - List</li><li>Accept-Patch - List</li><li>Accept-Ranges - List</li><li>Access-Control-Allow-Credentials - Item</li><li>Access-Control-Allow-Headers - List</li><li>Access-Control-Allow-Methods - List</li><li>Access-Control-Allow-Origin - Item</li><li>Access-Control-Max-Age - Item</li><li>Access-Control-Request-Headers - List</li><li>Access-Control-Request-Method - Item</li><li>Age - Item</li><li>Allow - List</li><li>ALPN - List</li><li>Alt-Svc - List</li><li>Alt-Used - Item</li><li>Cache-Control - Dictionary</li><li>Content-Encoding - Item</li><li>Content-Language - List</li><li>Content-Length - Item</li><li>Content-Type - Item</li><li>Expect - Item</li><li>Forwarded - List</li><li>Host - Item</li><li>Origin - Item</li><li>Pragma - Dictionary</li><li>Prefer - Dictionary</li><li>Preference-Applied - Dictionary</li><li>Retry-After - Item (see caveat below)</li><li>Surrogate-Control - Dictionary</li><li>TE - List</li><li>Trailer - List</li><li>Transfer-Encoding - List</li><li>Vary - List</li><li>X-Content-Type-Options - Item</li></ul></div><div id="rfc.section.4.1.p.4"><p>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div></section><section id="aliased"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a>&nbsp;<a href="#aliased">Aliased Fields</a></h3><div id="rfc.section.4.2.p.1"><p>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</p></div><div id="rfc.section.4.2.p.2" class="avoidbreakafter"><p>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</p></div><div id="rfc.figure.u.15"><div><pre>
Date: Sun, 06 Nov 1994 08:49:37 GMT
</pre></div></div><div id="rfc.section.4.2.p.3" class="avoidbreakafter"><p>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</p></div><div id="rfc.figure.u.16"><div><pre>
SH-Date: 784072177
</pre></div></div><div id="rfc.section.4.2.p.4"><p>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>).</p></div><div id="rfc.section.4.2.p.5"><p>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <a href="#negotiate" title="Using Binary Structured Headers in HTTP/2">Section&nbsp;3</a>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</p></div><div id="rfc.section.4.2.p.6"><p>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</p></div><div id="rfc.section.4.2.p.7"><p>ISSUE: using separate names assures that the different syntax doesn’t “leak” into normal headers, but it isn’t strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn’t understand this. <a href="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</a></p></div><section id="urls"><h4 id="rfc.section.4.2.1"><a href="#rfc.section.4.2.1">4.2.1.</a>&nbsp;<a href="#urls">URLs</a></h4><div id="rfc.section.4.2.1.p.1"><p>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</p></div><div id="rfc.section.4.2.1.p.2"><ul><li>Content-Location - SH-Content-Location</li><li>Location - SH-Location</li><li>Referer - SH-Referer</li></ul></div><div id="rfc.section.4.2.1.p.3" class="avoidbreakafter"><p>For example, a (non-binary) Location:</p></div><div id="rfc.figure.u.17"><div><pre>
SH-Location: "https://example.com/foo"
</pre></div></div><div id="rfc.section.4.2.1.p.4"><p>TOOD: list of strings, one for each path segment, to allow better compression in the future?</p></div></section><section id="dates"><h4 id="rfc.section.4.2.2"><a href="#rfc.section.4.2.2">4.2.2.</a>&nbsp;<a href="#dates">Dates</a></h4><div id="rfc.section.4.2.2.p.1"><p>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <a href="#RFC7230"><cite title="Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing">[RFC7230]</cite></a>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</p></div><div id="rfc.section.4.2.2.p.2"><ul><li>Date - SH-Date</li><li>Expires - SH-Expires</li><li>If-Modified-Since - SH-IMS</li><li>If-Unmodified-Since - SH-IUS</li><li>Last-Modified - SH-LM</li></ul></div><div id="rfc.section.4.2.2.p.3" class="avoidbreakafter"><p>For example, a (non-binary) Expires:</p></div><div id="rfc.figure.u.18"><div><pre>
SH-Expires: 1571965240
</pre></div></div></section><section id="etags"><h4 id="rfc.section.4.2.3"><a href="#rfc.section.4.2.3">4.2.3.</a>&nbsp;<a href="#etags">ETags</a></h4><div id="rfc.section.4.2.3.p.1"><p>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</p></div><div id="rfc.section.4.2.3.p.2"><ul><li>ETag - SH-ETag</li></ul></div><div id="rfc.section.4.2.3.p.3" class="avoidbreakafter"><p>For example, a (non-Binary) ETag:</p></div><div id="rfc.figure.u.19"><div><pre>
SH-ETag: "abcdef"; w=?1
</pre></div></div><div id="rfc.section.4.2.3.p.4"><p>If-None-Match is a list of the structure described above.</p></div><div id="rfc.section.4.2.3.p.5"><ul><li>If-None-Match - SH-INM</li></ul></div><div id="rfc.section.4.2.3.p.6" class="avoidbreakafter"><p>For example, a (non-binary) If-None-Match:</p></div><div id="rfc.figure.u.20"><div><pre>
SH-INM: "abcdef"; w=?1, "ghijkl"
</pre></div></div></section><section id="links"><h4 id="rfc.section.4.2.4"><a href="#rfc.section.4.2.4">4.2.4.</a>&nbsp;<a href="#links">Links</a></h4><div id="rfc.section.4.2.4.p.1"><p>The field-value of the Link header field <a href="#RFC8288"><cite title="Web Linking">[RFC8288]</cite></a> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</p></div><div id="rfc.section.4.2.4.p.2"><ul><li>Link: SH-Link</li></ul></div><div id="rfc.section.4.2.4.p.3" class="avoidbreakafter"><p>For example, a (non-binary) Link:</p></div><div id="rfc.figure.u.21"><div><pre>
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
</pre></div></div></section><section id="cookies"><h4 id="rfc.section.4.2.5"><a href="#rfc.section.4.2.5">4.2.5.</a>&nbsp;<a href="#cookies">Cookies</a></h4><div id="rfc.section.4.2.5.p.1"><p>The field-value of the Cookie and Set-Cookie fields <a href="#RFC6265"><cite title="HTTP State Management Mechanism">[RFC6265]</cite></a> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</p></div><div id="rfc.section.4.2.5.p.2"><p>Set-Cookie: SH-Set-Cookie Cookie: SH-Cookie</p></div><div id="rfc.figure.u.22"><div><pre>
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
</pre></div></div><div id="rfc.section.4.2.5.p.3"><p>ISSUE: explicitly convert Expires to an integer? <a href="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</a></p></div></section></section></section><section id="iana-considerations"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#iana-considerations">IANA Considerations</a></h2><div id="rfc.section.5.p.1"><p>ISSUE: todo</p></div></section><section id="security-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#security-considerations">Security Considerations</a></h2><div id="rfc.section.6.p.1"><p>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</p></div><div id="rfc.section.6.p.2"><p>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values (<a href="#TFV" title="Textual Field Values">Section&nbsp;2.4</a>). Therefore, implementation divergence from this strictness can have security impact.</p></div></section><section><div id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Normative References</h2><dl class="dl-horizontal"><dt id="I-D.ietf-httpbis-header-structure">[I-D.ietf-httpbis-header-structure]</dt><dd>Nottingham, M. and P. Kamp, “<a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-13">Structured Headers for HTTP</a>”, Internet-Draft&nbsp;draft-ietf-httpbis-header-structure-13 (<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-header-structure">work in progress</a>), August&nbsp;2019.</dd><dt id="RFC2119">[RFC2119]</dt><dd>Bradner, S., “<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>”, BCP&nbsp;14, RFC&nbsp;2119, <a href="http://dx.doi.org/10.17487/RFC2119">DOI&nbsp;10.17487/RFC2119</a>, March&nbsp;1997, &lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;.</dd><dt id="RFC6265">[RFC6265]</dt><dd>Barth, A., “<a href="https://tools.ietf.org/html/rfc6265">HTTP State Management Mechanism</a>”, RFC&nbsp;6265, <a href="http://dx.doi.org/10.17487/RFC6265">DOI&nbsp;10.17487/RFC6265</a>, April&nbsp;2011, &lt;<a href="https://www.rfc-editor.org/info/rfc6265">https://www.rfc-editor.org/info/rfc6265</a>&gt;.</dd><dt id="RFC7230">[RFC7230]</dt><dd>Fielding, R., Ed. and J. Reschke, Ed., “<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>”, RFC&nbsp;7230, <a href="http://dx.doi.org/10.17487/RFC7230">DOI&nbsp;10.17487/RFC7230</a>, June&nbsp;2014, &lt;<a href="https://www.rfc-editor.org/info/rfc7230">https://www.rfc-editor.org/info/rfc7230</a>&gt;.</dd><dt id="RFC7540">[RFC7540]</dt><dd>Belshe, M., Peon, R., and M. Thomson, Ed., “<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>”, RFC&nbsp;7540, <a href="http://dx.doi.org/10.17487/RFC7540">DOI&nbsp;10.17487/RFC7540</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;.</dd><dt id="RFC7541">[RFC7541]</dt><dd>Peon, R. and H. Ruellan, “<a href="https://tools.ietf.org/html/rfc7541">HPACK: Header Compression for HTTP/2</a>”, RFC&nbsp;7541, <a href="http://dx.doi.org/10.17487/RFC7541">DOI&nbsp;10.17487/RFC7541</a>, May&nbsp;2015, &lt;<a href="https://www.rfc-editor.org/info/rfc7541">https://www.rfc-editor.org/info/rfc7541</a>&gt;.</dd><dt id="RFC8174">[RFC8174]</dt><dd>Leiba, B., “<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>”, BCP&nbsp;14, RFC&nbsp;8174, <a href="http://dx.doi.org/10.17487/RFC8174">DOI&nbsp;10.17487/RFC8174</a>, May&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;.</dd><dt id="RFC8288">[RFC8288]</dt><dd>Nottingham, M., “<a href="https://tools.ietf.org/html/rfc8288">Web Linking</a>”, RFC&nbsp;8288, <a href="http://dx.doi.org/10.17487/RFC8288">DOI&nbsp;10.17487/RFC8288</a>, October&nbsp;2017, &lt;<a href="https://www.rfc-editor.org/info/rfc8288">https://www.rfc-editor.org/info/rfc8288</a>&gt;.</dd></dl></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Author's Address</a></h2><address><b>Mark Nottingham</b><br>Fastly<br>EMail: <a href="mailto:mnot@mnot.net">mnot@mnot.net</a><br>URI: <a href="https://www.mnot.net/">https://www.mnot.net/</a></address></section></div></div></div><script src="../Tools/node_modules/jquery/dist/jquery.min.js"></script><script src="../Tools/node_modules/bootstrap/dist/js/bootstrap.min.js"></script></body></html>