<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.37 -->
<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629-xhtml.ent">
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.5.0 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <city>Prahran</city>
          <region>VIC</region>
          <country>Australia</country>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
      <t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="RFC8941" format="default"/> offers a set of data types that new fields can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 -- specifically, as part of HPACK Literal Header Field Representations (<xref target="RFC7541" format="default"/>) -- in <xref target="negotiate" format="default"/>.</t>
      <t><xref target="backport" format="default"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>
      <t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Literal Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>The Binary Literal Representation</name>
        <t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541" format="default"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame" format="default"/>).</t>
        <t>All Binary Literal Representations of Field Values share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Structured Field Value {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the payload, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>List values (type=0x1) have a payload consisting of a stream of Binary Item Types representing the members of the list. Members that are Items are represented as per <xref target="types" format="default"/>; members that are inner-lists are represented as per <xref target="inner-list" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Item (..) ...
}
]]></artwork>
          <t>A List Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the entire List, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Item: One or more Item(s) (<xref target="types" format="default"/>)</li>
          </ul>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Dictionary values (type=0x2) have a payload consisting of a stream of Dictionary Members.</t>
          <t>Each member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Item Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>A Dictionary Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the entire Dictionary, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Dictionary Member: one or more Dictionary Member(s)</li>
          </ul>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Item (..),
  [Parameters (..)]
}

]]></artwork>
          <t>A Dictionary Member's fields are:</t>
          <ul spacing="normal">
            <li>Name Length: The number of octets used to represent the Member Name, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix</li>
            <li>Member Name: Name Length octets of the member-name, ASCII-encoded</li>
            <li>Item: An Item (<xref target="types" format="default"/>)</li>
            <li>Parameters: Optional Parameters (<xref target="parameter" format="default"/>)</li>
          </ul>
          <t>The Item in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Item values (type=0x3) have a payload consisting of Binary Item Types, as described in <xref target="types" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Item (..)
  [Parameters (..)]
}
]]></artwork>
          <t>An Item Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the Item, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Item: An Item (<xref target="types" format="default"/>)</li>
            <li>Parameters: Optional Parameters (<xref target="parameter" format="default"/>)</li>
          </ul>
          <t>The Item in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
        <section anchor="literal" numbered="true" toc="default">
          <name>String Literal Field Values</name>
          <t>String Literals (type=0x4) are the string value of a field; they are used to carry field values that are not Binary Structured Fields, and may not be Structured Fields at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541" format="default"/>, Section 5.2.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String Literal Field Value {
  Top Level Type (3) = 4,
  Length (5..),
  Payload (..)
}
]]></artwork>
          <t>A String Literal Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the string literal, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Payload: The octets of the field value</li>
          </ul>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Item Types</name>
        <t>Every Item starts with a 5-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Item {
  Type (5)
}
]]></artwork>
        <t>Some Binary Item Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (5) = 1,
  Length (3..),
  Item (..) ...
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the members, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix</li>
            <li>Members: Length octets</li>
          </ul>
          <t>An Item in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (5) = 2,
  Length (3..),
  Parameter (..) ...
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the payload, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix</li>
            <li>Payload: Length octets</li>
          </ul>
          <t>Each parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Item (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Parameter Value: A Binary Item Type representing a bare item (<xref target="types" format="default"/>)</li>
          </ul>
          <t>The Item in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Item Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Item in a container, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (5) = 3,
  Sign (1),
  Payload (2..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Item Type (5) = 4,
  Sign (1),
  Integer (2..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Item Type (5) = 5,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the string, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets, ASCII-encoded.</li>
          </ul>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Item Type (5) = 6,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the token, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets, ASCII-encoded.</li>
          </ul>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Item Type (5) = 7,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets.</li>
          </ul>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Item Type (5) = 8,
  Payload (1),
  Padding (2) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport" format="default"/>).</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in a frame type defined in <xref target="frame" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>Binary Structured Fields Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports the Binary Item Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINHEADERS frames as defined in <xref target="frame" format="default"/>.</li>
          <li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941" format="default"/>).</li>
          <li>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased" format="default"/>) into their non-aliased forms as necessary.</li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0. Future extensions to Structured Fields might use it to indicate support for new types.</t>
      </section>
      <section anchor="frame" numbered="true" toc="default">
        <name>The BINHEADERS Frame</name>
        <t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>
        <t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540" format="default"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541" format="default"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit" format="default"/>.</t>
        <t>Fields that are Structured Fields can have their values represented using the Binary Literal Representation corresponding to that field's top-level type -- List, Dictionary, or Item; their values will then be serialised as a stream of Binary Item Types.</t>
        <t>Additionally, any field (including those defined as Structured Fields) can be serialised as a String Literal (<xref target="literal" format="default"/>), which accommodates fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as Binary Item Types for some other reason.</t>
        <t>Note that Field Names are always serialised as String Literals (<xref target="literal" format="default"/>).</t>
        <t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Fields Types, and String Literals (<xref target="literal" format="default"/>) to their string counterparts.</t>
        <t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Item Types. In this case, the field types used are informed by the implementations knowledge of the individual field semantics; see <xref target="backport" format="default"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Fields are conveyed in BINHEADERS as String Literals (<xref target="literal" format="default"/>).</t>
        <t>Field values are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table without Huffman encoding, although specific Binary Item Types might specify the use of such encodings.</t>
        <t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Item Types; field names are encoded as they are in HPACK.</t>
      </section>
    </section>
    <section anchor="backport" numbered="true" toc="default">
      <name>Using Binary Structured Fields with Existing Fields</name>
      <t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure" format="default"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>
      <t>This section identifies fields that will usually succeed in <xref target="direct" format="default"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased" format="default"/>.</t>
      <section anchor="direct" numbered="true" toc="default">
        <name>Directly Represented Fields</name>
        <t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure" format="default"/>, and thus can usually be serialised using the corresponding Binary Item Types.</t>
        <t>When one of these fields' values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal" format="default"/>).</t>
        <ul spacing="normal">
          <li>Accept - List</li>
          <li>Accept-Encoding - List</li>
          <li>Accept-Language - List</li>
          <li>Accept-Patch - List</li>
          <li>Accept-Ranges - List</li>
          <li>Access-Control-Allow-Credentials - Item</li>
          <li>Access-Control-Allow-Headers - List</li>
          <li>Access-Control-Allow-Methods - List</li>
          <li>Access-Control-Allow-Origin - Item</li>
          <li>Access-Control-Max-Age - Item</li>
          <li>Access-Control-Request-Headers - List</li>
          <li>Access-Control-Request-Method - Item</li>
          <li>Age - Item</li>
          <li>Allow - List</li>
          <li>ALPN - List</li>
          <li>Alt-Svc - Dictionary</li>
          <li>Alt-Used - Item</li>
          <li>Cache-Control - Dictionary</li>
          <li>Connection - List</li>
          <li>Content-Encoding - List</li>
          <li>Content-Language - List</li>
          <li>Content-Length - Item</li>
          <li>Content-Type - Item</li>
          <li>Expect - Item</li>
          <li>Expect-CT - Dictionary</li>
          <li>Forwarded - Dictionary</li>
          <li>Host - Item</li>
          <li>Keep-Alive - Dictionary</li>
          <li>Origin - Item</li>
          <li>Pragma - Dictionary</li>
          <li>Prefer - Dictionary</li>
          <li>Preference-Applied - Dictionary</li>
          <li>Retry-After - Item  (see caveat below)</li>
          <li>Surrogate-Control - Dictionary</li>
          <li>TE - List</li>
          <li>Trailer - List</li>
          <li>Transfer-Encoding - List</li>
          <li>Vary - List</li>
          <li>X-Content-Type-Options - Item</li>
          <li>X-XSS-Protection - List</li>
        </ul>
        <t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal" format="default"/>).</t>
      </section>
      <section anchor="aliased" numbered="true" toc="default">
        <name>Aliased Fields</name>
        <t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>
        <t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork>
        <t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
SH-Date: 784072177
]]></artwork>
        <t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal" format="default"/>).</t>
        <t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate" format="default"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>
        <t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>
        <ul spacing="normal">
          <li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></li>
        </ul>
        <section anchor="urls" numbered="true" toc="default">
          <name>URLs</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>
          <ul spacing="normal">
            <li>Content-Location - SH-Content-Location</li>
            <li>Location - SH-Location</li>
            <li>Referer - SH-Referer</li>
          </ul>
          <t>For example, a (non-binary) Location:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork>
          <t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>
        </section>
        <section anchor="dates" numbered="true" toc="default">
          <name>Dates</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7230" format="default"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>
          <ul spacing="normal">
            <li>Date - SH-Date</li>
            <li>Expires - SH-Expires</li>
            <li>If-Modified-Since - SH-IMS</li>
            <li>If-Unmodified-Since - SH-IUS</li>
            <li>Last-Modified - SH-LM</li>
          </ul>
          <t>For example, a (non-binary) Expires:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SH-Expires: 1571965240
]]></artwork>
        </section>
        <section anchor="etags" numbered="true" toc="default">
          <name>ETags</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>
          <ul spacing="normal">
            <li>ETag - SH-ETag</li>
          </ul>
          <t>For example, a (non-Binary) ETag:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork>
          <t>If-None-Match is a list of the structure described above.</t>
          <ul spacing="normal">
            <li>If-None-Match - SH-INM</li>
          </ul>
          <t>For example, a (non-binary) If-None-Match:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork>
        </section>
        <section anchor="links" numbered="true" toc="default">
          <name>Links</name>
          <t>The field-value of the Link header field <xref target="RFC8288" format="default"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>
          <ul spacing="normal">
            <li>Link: SH-Link</li>
          </ul>
          <t>For example, a (non-binary) Link:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork>
        </section>
        <section anchor="cookies" numbered="true" toc="default">
          <name>Cookies</name>
          <t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265" format="default"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>
          <t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork>
          <ul spacing="normal">
            <li>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></li>
            <li>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></li>
            <li>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of String Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="I-D.ietf-quic-transport" target="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="Jana Iyengar">
            <organization>Fastly</organization>
          </author>
          <author fullname="Martin Thomson">
            <organization>Mozilla</organization>
          </author>
          <date day="14" month="January" year="2021"/>
          <abstract>
            <t>   This document defines the core of the QUIC transport protocol.  QUIC
   provides applications with flow-controlled streams for structured
   communication, low-latency connection establishment, and network path
   migration.  QUIC includes security measures that ensure
   confidentiality, integrity, and availability in a range of deployment
   circumstances.  Accompanying documents describe the integration of
   TLS for key negotiation, loss detection, and an exemplary congestion
   control algorithm.

DO NOT DEPLOY THIS VERSION OF QUIC

   DO NOT DEPLOY THIS VERSION OF QUIC UNTIL IT IS IN AN RFC.  This
   version is still a work in progress.  For trial deployments, please
   use earlier versions.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org (mailto:quic@ietf.org)), which is
   archived at https://mailarchive.ietf.org/arch/search/?email_list=quic

   Working Group information can be found at https://github.com/quicwg;
   source code and issues list for this draft can be found at
   https://github.com/quicwg/base-drafts/labels/-transport.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport-34"/>
      </reference>
      <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
      <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540">
        <front>
          <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
          <author fullname="M. Belshe" initials="M." surname="Belshe">
            <organization/>
          </author>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t>
            <t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7540"/>
        <seriesInfo name="DOI" value="10.17487/RFC7540"/>
      </reference>
      <reference anchor="I-D.ietf-httpbis-header-structure" target="https://www.ietf.org/archive/id/draft-ietf-httpbis-header-structure-19.txt">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="Mark Nottingham">
            <organization>Fastly</organization>
          </author>
          <author fullname="Poul-Henning Kamp">
            <organization>The Varnish Cache Project</organization>
          </author>
          <date day="3" month="June" year="2020"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers".  It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.
            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-httpbis-header-structure-19"/>
      </reference>
      <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding">
            <organization/>
          </author>
          <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke">
            <organization/>
          </author>
          <date month="June" year="2014"/>
          <abstract>
            <t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7230"/>
        <seriesInfo name="DOI" value="10.17487/RFC7230"/>
      </reference>
      <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288">
        <front>
          <title>Web Linking</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <date month="October" year="2017"/>
          <abstract>
            <t>This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
            <t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8288"/>
        <seriesInfo name="DOI" value="10.17487/RFC8288"/>
      </reference>
      <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author fullname="A. Barth" initials="A." surname="Barth">
            <organization/>
          </author>
          <date month="April" year="2011"/>
          <abstract>
            <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6265"/>
        <seriesInfo name="DOI" value="10.17487/RFC6265"/>
      </reference>
    </references>
    <section anchor="data-supporting-directly-represented-field-mappings" numbered="true" toc="default">
      <name>Data Supporting Directly Represented Field Mappings</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct" format="default"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>
      <ul spacing="normal">
        <li>accept: 9,198 / 10 = 0.109%</li>
        <li>accept-encoding: 34,157 / 74 = 0.216%</li>
        <li>accept-language: 381,034 / 512 = 0.134%</li>
        <li>accept-patch: 5 / 0 = 0.000%</li>
        <li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li>
        <li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li>
        <li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li>
        <li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li>
        <li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li>
        <li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li>
        <li>access-control-request-headers: 39,328 / 624 = 1.562%</li>
        <li>access-control-request-method: 146,259 / 13,821 = 8.634%</li>
        <li>age: 71,281,684 / 172,398 = 0.241%</li>
        <li>allow: 351,704 / 1,886 = 0.533%</li>
        <li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li>
        <li>cache-control: 264,805,256 / 782,896 = 0.295%</li>
        <li>connection: 105,876,072 / 2,915 = 0.003%</li>
        <li>content-encoding: 139,799,523 / 379 = 0.000%</li>
        <li>content-language: 2,367,162 / 728 = 0.031%</li>
        <li>content-length: 296,624,718 / 787,843 = 0.265%</li>
        <li>content-type: 341,918,716 / 795,676 = 0.232%</li>
        <li>expect: 0 / 47 = 100.000%</li>
        <li>expect-ct: 26,569,605 / 29,114 = 0.109%</li>
        <li>forwarded: 119 / 35 = 22.727%</li>
        <li>host: 25,333 / 1,441 = 5.382%</li>
        <li>keep-alive: 43,061,546 / 796 = 0.002%</li>
        <li>origin: 24,335 / 1,539 = 5.948%</li>
        <li>pragma: 46,820,588 / 81,700 = 0.174%</li>
        <li>preference-applied: 57 / 0 = 0.000%</li>
        <li>retry-after: 605,844 / 6,195 = 1.012%</li>
        <li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li>
        <li>surrogate-control: 121,118 / 861 = 0.706%</li>
        <li>te: 1 / 0 = 0.000%</li>
        <li>trailer: 282 / 0 = 0.000%</li>
        <li>transfer-encoding: 13,952,661 / 0 = 0.000%</li>
        <li>vary: 150,787,199 / 41,313 = 0.027%</li>
        <li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li>
        <li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li>
      </ul>
      <t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>
      <t><tt>alt-svc</tt> has a high failure rate because some currently-used ALPN tokens (e.g., <tt>h3-Q43</tt>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <tt>h3</tt> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>
      <t><tt>forwarded</tt> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <tt>for=192.168.1.1</tt>.</t>
      <t><tt>strict-transport-security</tt> has a high failure rate because the <tt>includeSubDomains</tt> flag does not conform to the key syntax.</t>
      <t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>
      <ul spacing="normal">
        <li>date: 354,652,447</li>
        <li>server: 311,275,961</li>
        <li>last-modified: 263,832,615</li>
        <li>expires: 199,967,042</li>
        <li>status: 192,423,509</li>
        <li>etag: 172,058,269</li>
        <li>timing-allow-origin: 64,407,586</li>
        <li>x-cache: 41,740,804</li>
        <li>p3p: 39,490,058</li>
        <li>x-frame-options: 34,037,985</li>
      </ul>
    </section>
  </back>
  <!-- ##markdown-source:
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

-->

</rfc>
