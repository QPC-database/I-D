<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.37 -->
<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629-xhtml.ent">
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.5.0 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <city>Prahran</city>
          <region>VIC</region>
          <country>Australia</country>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
      <t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="RFC8941" format="default"/> offers a set of data types that new fields can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 -- specifically, as part of HPACK Literal Header Field Representations (<xref target="RFC7541" format="default"/>) -- in <xref target="negotiate" format="default"/>.</t>
      <t><xref target="backport" format="default"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>
      <t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Literal Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>The Binary Literal Representation</name>
        <t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541" format="default"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame" format="default"/>).</t>
        <t>All Binary Literal Representations of Field Values share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Structured Field Value {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the payload, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>List values (type=0x1) have a payload consisting of a stream of Binary Item Types representing the members of the list. Members that are Items are represented as per <xref target="types" format="default"/>; members that are inner-lists are represented as per <xref target="inner-list" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Item (..) ...
}
]]></artwork>
          <t>A List Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the entire List, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Item: One or more Item(s) (<xref target="types" format="default"/>)</li>
          </ul>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Dictionary values (type=0x2) have a payload consisting of a stream of Dictionary Members.</t>
          <t>Each member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Item Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>A Dictionary Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the entire Dictionary, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Dictionary Member: one or more Dictionary Member(s)</li>
          </ul>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Item (..),
  [Parameters (..)]
}

]]></artwork>
          <t>A Dictionary Member's fields are:</t>
          <ul spacing="normal">
            <li>Name Length: The number of octets used to represent the Member Name, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix</li>
            <li>Member Name: Name Length octets of the member-name, ASCII-encoded</li>
            <li>Item: An Item (<xref target="types" format="default"/>)</li>
            <li>Parameters: Optional Parameters (<xref target="parameter" format="default"/>)</li>
          </ul>
          <t>The Item in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Item values (type=0x3) have a payload consisting of Binary Item Types, as described in <xref target="types" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Item (..)
  [Parameters (..)]
}
]]></artwork>
          <t>An Item Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the Item, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Item: An Item (<xref target="types" format="default"/>)</li>
            <li>Parameters: Optional Parameters (<xref target="parameter" format="default"/>)</li>
          </ul>
          <t>The Item in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
        <section anchor="literal" numbered="true" toc="default">
          <name>String Literal Field Values</name>
          <t>String Literals (type=0x4) are the string value of a field; they are used to carry field values that are not Binary Structured Fields, and may not be Structured Fields at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541" format="default"/>, Section 5.2.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String Literal Field Value {
  Top Level Type (3) = 4,
  Length (5..),
  Payload (..)
}
]]></artwork>
          <t>A String Literal Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the string literal, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Payload: The octets of the field value</li>
          </ul>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Item Types</name>
        <t>Every Item starts with a 5-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Item {
  Type (5)
}
]]></artwork>
        <t>Some Binary Item Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (5) = 1,
  Length (3..),
  Item (..) ...
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the members, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix</li>
            <li>Members: Length octets</li>
          </ul>
          <t>An Item in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (5) = 2,
  Length (3..),
  Parameter (..) ...
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the payload, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix</li>
            <li>Payload: Length octets</li>
          </ul>
          <t>Each parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Item (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Parameter Value: A Binary Item Type representing a bare item (<xref target="types" format="default"/>)</li>
          </ul>
          <t>The Item in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Item Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Item in a container, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (5) = 3,
  Sign (1),
  Payload (2..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Item Type (5) = 4,
  Sign (1),
  Integer (2..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Item Type (5) = 5,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the string, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets, ASCII-encoded.</li>
          </ul>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Item Type (5) = 6,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the token, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets, ASCII-encoded.</li>
          </ul>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Item Type (5) = 7,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets.</li>
          </ul>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Item Type (5) = 8,
  Payload (1),
  Padding (2) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport" format="default"/>).</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in a frame type defined in <xref target="frame" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>Binary Structured Fields Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports the Binary Item Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINHEADERS frames as defined in <xref target="frame" format="default"/>.</li>
          <li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941" format="default"/>).</li>
          <li>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased" format="default"/>) into their non-aliased forms as necessary.</li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0. Future extensions to Structured Fields might use it to indicate support for new types.</t>
      </section>
      <section anchor="frame" numbered="true" toc="default">
        <name>The BINHEADERS Frame</name>
        <t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>
        <t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540" format="default"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541" format="default"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit" format="default"/>.</t>
        <t>Fields that are Structured Fields can have their values represented using the Binary Literal Representation corresponding to that field's top-level type -- List, Dictionary, or Item; their values will then be serialised as a stream of Binary Item Types.</t>
        <t>Additionally, any field (including those defined as Structured Fields) can be serialised as a String Literal (<xref target="literal" format="default"/>), which accommodates fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as Binary Item Types for some other reason.</t>
        <t>Note that Field Names are always serialised as String Literals (<xref target="literal" format="default"/>).</t>
        <t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Fields Types, and String Literals (<xref target="literal" format="default"/>) to their string counterparts.</t>
        <t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Item Types. In this case, the field types used are informed by the implementations knowledge of the individual field semantics; see <xref target="backport" format="default"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Fields are conveyed in BINHEADERS as String Literals (<xref target="literal" format="default"/>).</t>
        <t>Field values are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table without Huffman encoding, although specific Binary Item Types might specify the use of such encodings.</t>
        <t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Item Types; field names are encoded as they are in HPACK.</t>
      </section>
    </section>
    <section anchor="backport" numbered="true" toc="default">
      <name>Using Binary Structured Fields with Existing Fields</name>
      <t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941" format="default"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>
      <t>This section identifies fields that will usually succeed in <xref target="direct" format="default"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased" format="default"/>.</t>
      <section anchor="direct" numbered="true" toc="default">
        <name>Directly Represented Fields</name>
        <t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941" format="default"/>, and thus can usually be serialised using the corresponding Binary Item Types.</t>
        <t>When one of these fields' values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal" format="default"/>).</t>
        <ul spacing="normal">
          <li>Accept - List</li>
          <li>Accept-Encoding - List</li>
          <li>Accept-Language - List</li>
          <li>Accept-Patch - List</li>
          <li>Accept-Ranges - List</li>
          <li>Access-Control-Allow-Credentials - Item</li>
          <li>Access-Control-Allow-Headers - List</li>
          <li>Access-Control-Allow-Methods - List</li>
          <li>Access-Control-Allow-Origin - Item</li>
          <li>Access-Control-Max-Age - Item</li>
          <li>Access-Control-Request-Headers - List</li>
          <li>Access-Control-Request-Method - Item</li>
          <li>Age - Item</li>
          <li>Allow - List</li>
          <li>ALPN - List</li>
          <li>Alt-Svc - Dictionary</li>
          <li>Alt-Used - Item</li>
          <li>Cache-Control - Dictionary</li>
          <li>Connection - List</li>
          <li>Content-Encoding - List</li>
          <li>Content-Language - List</li>
          <li>Content-Length - Item</li>
          <li>Content-Type - Item</li>
          <li>Expect - Item</li>
          <li>Expect-CT - Dictionary</li>
          <li>Forwarded - Dictionary</li>
          <li>Host - Item</li>
          <li>Keep-Alive - Dictionary</li>
          <li>Origin - Item</li>
          <li>Pragma - Dictionary</li>
          <li>Prefer - Dictionary</li>
          <li>Preference-Applied - Dictionary</li>
          <li>Retry-After - Item  (see caveat below)</li>
          <li>Surrogate-Control - Dictionary</li>
          <li>TE - List</li>
          <li>Trailer - List</li>
          <li>Transfer-Encoding - List</li>
          <li>Vary - List</li>
          <li>X-Content-Type-Options - Item</li>
          <li>X-XSS-Protection - List</li>
        </ul>
        <t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal" format="default"/>).</t>
      </section>
      <section anchor="aliased" numbered="true" toc="default">
        <name>Aliased Fields</name>
        <t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>
        <t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork>
        <t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Date: 784072177
]]></artwork>
        <t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal" format="default"/>).</t>
        <t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate" format="default"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>
        <t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>
        <ul spacing="normal">
          <li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></li>
        </ul>
        <section anchor="urls" numbered="true" toc="default">
          <name>URLs</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>
          <ul spacing="normal">
            <li>Content-Location - SF-Content-Location</li>
            <li>Location - SF-Location</li>
            <li>Referer - SF-Referer</li>
          </ul>
          <t>For example, a (non-binary) Location:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork>
          <t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>
        </section>
        <section anchor="dates" numbered="true" toc="default">
          <name>Dates</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7230" format="default"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>
          <ul spacing="normal">
            <li>Date - SF-Date</li>
            <li>Expires - SF-Expires</li>
            <li>If-Modified-Since - SF-IMS</li>
            <li>If-Unmodified-Since - SF-IUS</li>
            <li>Last-Modified - SF-LM</li>
          </ul>
          <t>For example, a (non-binary) Expires:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Expires: 1571965240
]]></artwork>
        </section>
        <section anchor="etags" numbered="true" toc="default">
          <name>ETags</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>
          <ul spacing="normal">
            <li>ETag - SF-ETag</li>
          </ul>
          <t>For example, a (non-Binary) ETag:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork>
          <t>If-None-Match is a list of the structure described above.</t>
          <ul spacing="normal">
            <li>If-None-Match - SF-INM</li>
          </ul>
          <t>For example, a (non-binary) If-None-Match:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork>
        </section>
        <section anchor="links" numbered="true" toc="default">
          <name>Links</name>
          <t>The field-value of the Link header field <xref target="RFC8288" format="default"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>
          <ul spacing="normal">
            <li>Link: SF-Link</li>
          </ul>
          <t>For example, a (non-binary) Link:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork>
        </section>
        <section anchor="cookies" numbered="true" toc="default">
          <name>Cookies</name>
          <t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265" format="default"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>
          <t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork>
          <ul spacing="normal">
            <li>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></li>
            <li>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></li>
            <li>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of String Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="I-D.ietf-quic-transport" target="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="Jana Iyengar">
            <organization>Fastly</organization>
          </author>
          <author fullname="Martin Thomson">
            <organization>Mozilla</organization>
          </author>
          <date day="14" month="January" year="2021"/>
          <abstract>
            <t>   This document defines the core of the QUIC transport protocol.  QUIC
   provides applications with flow-controlled streams for structured
   communication, low-latency connection establishment, and network path
   migration.  QUIC includes security measures that ensure
   confidentiality, integrity, and availability in a range of deployment
   circumstances.  Accompanying documents describe the integration of
   TLS for key negotiation, loss detection, and an exemplary congestion
   control algorithm.

DO NOT DEPLOY THIS VERSION OF QUIC

   DO NOT DEPLOY THIS VERSION OF QUIC UNTIL IT IS IN AN RFC.  This
   version is still a work in progress.  For trial deployments, please
   use earlier versions.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org (mailto:quic@ietf.org)), which is
   archived at https://mailarchive.ietf.org/arch/search/?email_list=quic

   Working Group information can be found at https://github.com/quicwg;
   source code and issues list for this draft can be found at
   https://github.com/quicwg/base-drafts/labels/-transport.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport-34"/>
      </reference>
      <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
      <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540">
        <front>
          <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
          <author fullname="M. Belshe" initials="M." surname="Belshe">
            <organization/>
          </author>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t>
            <t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7540"/>
        <seriesInfo name="DOI" value="10.17487/RFC7540"/>
      </reference>
      <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding">
            <organization/>
          </author>
          <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke">
            <organization/>
          </author>
          <date month="June" year="2014"/>
          <abstract>
            <t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7230"/>
        <seriesInfo name="DOI" value="10.17487/RFC7230"/>
      </reference>
      <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288">
        <front>
          <title>Web Linking</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <date month="October" year="2017"/>
          <abstract>
            <t>This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
            <t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8288"/>
        <seriesInfo name="DOI" value="10.17487/RFC8288"/>
      </reference>
      <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author fullname="A. Barth" initials="A." surname="Barth">
            <organization/>
          </author>
          <date month="April" year="2011"/>
          <abstract>
            <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6265"/>
        <seriesInfo name="DOI" value="10.17487/RFC6265"/>
      </reference>
    </references>
    <section anchor="data-supporting-directly-represented-field-mappings" numbered="true" toc="default">
      <name>Data Supporting Directly Represented Field Mappings</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct" format="default"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>
      <ul spacing="normal">
        <li>accept: 9,198 / 10 = 0.109%</li>
        <li>accept-encoding: 34,157 / 74 = 0.216%</li>
        <li>accept-language: 381,034 / 512 = 0.134%</li>
        <li>accept-patch: 5 / 0 = 0.000%</li>
        <li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li>
        <li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li>
        <li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li>
        <li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li>
        <li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li>
        <li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li>
        <li>access-control-request-headers: 39,328 / 624 = 1.562%</li>
        <li>access-control-request-method: 146,259 / 13,821 = 8.634%</li>
        <li>age: 71,281,684 / 172,398 = 0.241%</li>
        <li>allow: 351,704 / 1,886 = 0.533%</li>
        <li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li>
        <li>cache-control: 264,805,256 / 782,896 = 0.295%</li>
        <li>connection: 105,876,072 / 2,915 = 0.003%</li>
        <li>content-encoding: 139,799,523 / 379 = 0.000%</li>
        <li>content-language: 2,367,162 / 728 = 0.031%</li>
        <li>content-length: 296,624,718 / 787,843 = 0.265%</li>
        <li>content-type: 341,918,716 / 795,676 = 0.232%</li>
        <li>expect: 0 / 47 = 100.000%</li>
        <li>expect-ct: 26,569,605 / 29,114 = 0.109%</li>
        <li>forwarded: 119 / 35 = 22.727%</li>
        <li>host: 25,333 / 1,441 = 5.382%</li>
        <li>keep-alive: 43,061,546 / 796 = 0.002%</li>
        <li>origin: 24,335 / 1,539 = 5.948%</li>
        <li>pragma: 46,820,588 / 81,700 = 0.174%</li>
        <li>preference-applied: 57 / 0 = 0.000%</li>
        <li>retry-after: 605,844 / 6,195 = 1.012%</li>
        <li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li>
        <li>surrogate-control: 121,118 / 861 = 0.706%</li>
        <li>te: 1 / 0 = 0.000%</li>
        <li>trailer: 282 / 0 = 0.000%</li>
        <li>transfer-encoding: 13,952,661 / 0 = 0.000%</li>
        <li>vary: 150,787,199 / 41,313 = 0.027%</li>
        <li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li>
        <li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li>
      </ul>
      <t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>
      <t><tt>alt-svc</tt> has a high failure rate because some currently-used ALPN tokens (e.g., <tt>h3-Q43</tt>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <tt>h3</tt> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>
      <t><tt>forwarded</tt> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <tt>for=192.168.1.1</tt>.</t>
      <t><tt>strict-transport-security</tt> has a high failure rate because the <tt>includeSubDomains</tt> flag does not conform to the key syntax.</t>
      <t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>
      <ul spacing="normal">
        <li>date: 354,652,447</li>
        <li>server: 311,275,961</li>
        <li>last-modified: 263,832,615</li>
        <li>expires: 199,967,042</li>
        <li>status: 192,423,509</li>
        <li>etag: 172,058,269</li>
        <li>timing-allow-origin: 64,407,586</li>
        <li>x-cache: 41,740,804</li>
        <li>p3p: 39,490,058</li>
        <li>x-frame-options: 34,037,985</li>
      </ul>
    </section>
  </back>
  <!-- ##markdown-source:
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
7HSHznjUp+a+1v8DdyaH+/BeAAA=

-->

</rfc>
