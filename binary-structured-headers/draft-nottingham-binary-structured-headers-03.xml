<?xml version='1.0' encoding='utf-8'?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.3.37 -->
<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629-xhtml.ent">
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-nottingham-binary-structured-headers-03" category="std" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <!-- xml2rfc v2v3 conversion 3.5.0 -->
  <front>
    <title>Binary Structured HTTP Field Values</title>
    <seriesInfo name="Internet-Draft" value="draft-nottingham-binary-structured-headers-03"/>
    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <postal>
          <city>Prahran</city>
          <region>VIC</region>
          <country>Australia</country>
        </postal>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>
    <date/>
    <area>General</area>
    <keyword>Internet-Draft</keyword>
    <abstract>
      <t>This specification defines a binary serialisation of Structured Field Values for HTTP, along with a negotiation mechanism for its use in HTTP/2.</t>
      <t>It also defines how to use Structured Fields for many existing fields -- thereby "backporting" them -- when supported by both peers.</t>
    </abstract>
    <note>
      <name>Note to Readers</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>
      <t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>
      <t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>
      <t>See also the draft's current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>
    </note>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Structured Field Values for HTTP <xref target="RFC8941" format="default"/> offers a set of data types that new fields can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="fields" format="default"/>, and specifies its use in HTTP/2 -- specifically, as part of HPACK Literal Header Field Representations (<xref target="RFC7541" format="default"/>) -- in <xref target="negotiate" format="default"/>.</t>
      <t><xref target="backport" format="default"/> defines how to convey existing fields as Structured Fields, when supported by two peers.</t>
      <t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Fields. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular field compression mechanisms.</t>
      <section anchor="notational-conventions" numbered="true" toc="default">
        <name>Notational Conventions</name>
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/> when, and only when, they appear in all capitals, as
shown here.</t>
        <t>This specification describes formats using the convention described in <xref section="1.3" sectionFormat="of" target="I-D.ietf-quic-transport" format="default"/>.</t>
      </section>
    </section>
    <section anchor="fields" numbered="true" toc="default">
      <name>Binary Structured Fields</name>
      <t>This section defines a binary serialisation for the Structured Field Types defined in <xref target="RFC8941" format="default"/>.</t>
      <t>The types permissable as the top-level of Structured Field values -- Dictionary, List, and Item -- are defined in terms of a Binary Literal Representation (<xref target="binlit" format="default"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541" format="default"/>.</t>
      <t>Binary representations of the remaining types are defined in <xref target="types" format="default"/>.</t>
      <section anchor="binlit" numbered="true" toc="default">
        <name>The Binary Literal Representation</name>
        <t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541" format="default"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame" format="default"/>).</t>
        <t>All Binary Literal Representations of Field Values share the following header:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Binary Structured Field Value {
  Top Level Type (3),
  Length (5..),
}
]]></artwork>
        <t>Its fields are:</t>
        <ul spacing="normal">
          <li>Top Level Type: Three bits indicating the top-level type of the field value.</li>
          <li>Length: The number of octets used to represent the payload, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix.</li>
        </ul>
        <t>The following top-level types are defined:</t>
        <section anchor="list-field-values" numbered="true" toc="default">
          <name>List Field Values</name>
          <t>List values (type=0x1) have a payload consisting of a stream of Binary Item Types representing the members of the list. Members that are Items are represented as per <xref target="types" format="default"/>; members that are inner-lists are represented as per <xref target="inner-list" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
List Field Value {
  Top Level Type (3) = 1,
  Length (5..),
  Item (..) ...
}
]]></artwork>
          <t>A List Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the entire List, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Item: One or more Item(s) (<xref target="types" format="default"/>)</li>
          </ul>
        </section>
        <section anchor="dictionary-field-values" numbered="true" toc="default">
          <name>Dictionary Field Values</name>
          <t>Dictionary values (type=0x2) have a payload consisting of a stream of Dictionary Members.</t>
          <t>Each member is represented by a length, followed by that many bytes of the member-name, followed by the Binary Item Type(s) representing the member-value.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Field Value {
  Top Level Type (3) = 2,
  Length (5..),
  Dictionary Member (..) ...
}
]]></artwork>
          <t>A Dictionary Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the entire Dictionary, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Dictionary Member: one or more Dictionary Member(s)</li>
          </ul>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Dictionary Member {
  Name Length (8..),
  Member Name (..),
  Item (..),
  [Parameters (..)]
}

]]></artwork>
          <t>A Dictionary Member's fields are:</t>
          <ul spacing="normal">
            <li>Name Length: The number of octets used to represent the Member Name, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix</li>
            <li>Member Name: Name Length octets of the member-name, ASCII-encoded</li>
            <li>Item: An Item (<xref target="types" format="default"/>)</li>
            <li>Parameters: Optional Parameters (<xref target="parameter" format="default"/>)</li>
          </ul>
          <t>The Item in a Dictionary Member MUST NOT be a Parameters (0x2).</t>
        </section>
        <section anchor="item-field-values" numbered="true" toc="default">
          <name>Item Field Values</name>
          <t>Item values (type=0x3) have a payload consisting of Binary Item Types, as described in <xref target="types" format="default"/>.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Item Field Value {
  Top Level Type (3) = 3,
  Length (5..),
  Item (..)
  [Parameters (..)]
}
]]></artwork>
          <t>An Item Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the Item (including Parameters, if present), encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Item: An Item (<xref target="types" format="default"/>)</li>
            <li>Parameters: Optional Parameters (<xref target="parameter" format="default"/>)</li>
          </ul>
          <t>The Item in an Item Field Value MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
        </section>
        <section anchor="literal" numbered="true" toc="default">
          <name>String Literal Field Values</name>
          <t>String Literals (type=0x4) are the string value of a field; they are used to carry field values that are not Binary Structured Fields, and may not be Structured Fields at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541" format="default"/>, Section 5.2.</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String Literal Field Value {
  Top Level Type (3) = 4,
  Length (5..),
  Payload (..)
}
]]></artwork>
          <t>A String Literal Field Value's fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the string literal, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 5-bit prefix</li>
            <li>Payload: The raw octets of the field value</li>
          </ul>
        </section>
      </section>
      <section anchor="types" numbered="true" toc="default">
        <name>Binary Item Types</name>
        <t>Every Item starts with a 5-bit type field that identifies the format of its payload.</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Item {
  Type (5)
}
]]></artwork>
        <t>Some Binary Item Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>
        <section anchor="inner-list" numbered="true" toc="default">
          <name>Inner Lists</name>
          <t>The Inner List data type (type=0x1) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Inner List {
  Type (5) = 1,
  Length (3..),
  Item (..) ...
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the members, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix</li>
            <li>Item(s): Length octets containing the Item(s) in the List</li>
          </ul>
          <t>An Item in an Inner List MUST NOT be an Inner List (0x1).</t>
          <t>Parameters on the Inner List itself, if present, are serialised in a following Parameter type (<xref target="parameter" format="default"/>); they do not form part of the payload of the Inner List (and therefore are not counted in Length).</t>
        </section>
        <section anchor="parameter" numbered="true" toc="default">
          <name>Parameters</name>
          <t>The Parameters data type (type=0x2) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameters {
  Type (5) = 2,
  Length (3..),
  Parameter (..) ...
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the payload, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix</li>
            <li>Parameter(s): Length octets</li>
          </ul>
          <t>Each Parameter conveys a key and a value:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Parameter {
  Parameter Name Length (8..),
  Parameter Name (..),
  Item (..)
}
]]></artwork>
          <t>A parameter's fields are:</t>
          <ul spacing="normal">
            <li>Parameter Name Length: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix</li>
            <li>Parameter Name: Parameter Name Length octets of the parameter-name</li>
            <li>Item: The parameter value, a Binary Item Type</li>
          </ul>
          <t>The Item in a Parameter MUST NOT be an Inner List (0x1) or Parameters (0x2).</t>
          <t>Parameters are always associated with the Binary Item Type that immediately preceded them. Therefore, Parameters MUST NOT be the first Item in a container, and MUST NOT follow another Parameters.</t>
        </section>
        <section anchor="integers" numbered="true" toc="default">
          <name>Integers</name>
          <t>The Integer data type (type=0x3) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Integer {
  Type (5) = 3,
  Sign (1),
  Payload (2..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Payload: The integer, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 2-bit prefix</li>
          </ul>
        </section>
        <section anchor="floats" numbered="true" toc="default">
          <name>Floats</name>
          <t>The Float data type (type=0x4) have a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Float {
  Item Type (5) = 4,
  Sign (1),
  Integer (2..),
  Fractional (8..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Sign: sign bit; 0 is negative, 1 is positive</li>
            <li>Integer: The integer component, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 2-bit prefix.</li>
            <li>Fractional: The fractional component, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 8-bit prefix.</li>
          </ul>
        </section>
        <section anchor="strings" numbered="true" toc="default">
          <name>Strings</name>
          <t>The String data type (type=0x5) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
String {
  Item Type (5) = 5,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the string, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets, ASCII-encoded.</li>
          </ul>
        </section>
        <section anchor="token" numbered="true" toc="default">
          <name>Tokens</name>
          <t>The Token data type (type=0x6) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Token {
  Item Type (5) = 6,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the token, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets, ASCII-encoded.</li>
          </ul>
        </section>
        <section anchor="byte-sequences" numbered="true" toc="default">
          <name>Byte Sequences</name>
          <t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Byte Sequence {
  Item Type (5) = 7,
  Length (3..),
  Payload (..)
}
]]></artwork>
          <t>Its fields are:</t>
          <ul spacing="normal">
            <li>Length: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541" format="default"/>, Section 5.1, with a 3-bit prefix.</li>
            <li>Payload: Length octets.</li>
          </ul>
        </section>
        <section anchor="booleans" numbered="true" toc="default">
          <name>Booleans</name>
          <t>The Boolean data type (type=0x8) has a payload of two bits:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
Boolean {
  Item Type (5) = 8,
  Payload (1),
  Padding (2) = 0
}
]]></artwork>
          <t>If Payload is 0, the value is False; if Payload is 1, the value is True.</t>
        </section>
      </section>
    </section>
    <section anchor="negotiate" numbered="true" toc="default">
      <name>Using Binary Structured Fields in HTTP/2</name>
      <t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise fields that they know to be Structured Fields (or compatible with them; see <xref target="backport" format="default"/>).</t>
      <t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting" format="default"/>, and convey Binary Structured Fields in a frame type defined in <xref target="frame" format="default"/>.</t>
      <section anchor="setting" numbered="true" toc="default">
        <name>Binary Structured Fields Setting</name>
        <t>Advertising support for Binary Structured Fields is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_FIELDS (0xTODO).</t>
        <t>Receiving SETTINGS_BINARY_STRUCTURED_FIELDS from a peer indicates that:</t>
        <ol spacing="normal" type="1"><li>The peer supports the Binary Item Types defined in <xref target="fields" format="default"/>.</li>
          <li>The peer will process the BINHEADERS frames as defined in <xref target="frame" format="default"/>.</li>
          <li>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Fields data types defined in <xref target="RFC8941" format="default"/>).</li>
          <li>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased" format="default"/>) into their non-aliased forms as necessary.</li>
        </ol>
        <t>The default value of SETTINGS_BINARY_STRUCTURED_FIELDS is 0. Future extensions to Structured Fields might use it to indicate support for new types.</t>
      </section>
      <section anchor="frame" numbered="true" toc="default">
        <name>The BINHEADERS Frame</name>
        <t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>
        <t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540" format="default"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541" format="default"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit" format="default"/>.</t>
        <t>Fields that are Structured Fields can have their values represented using the Binary Literal Representation corresponding to that field's top-level type -- List, Dictionary, or Item; their values will then be serialised as a stream of Binary Item Types.</t>
        <t>Additionally, any field (including those defined as Structured Fields) can be serialised as a String Literal (<xref target="literal" format="default"/>), which accommodates fields that are not defined as Structured Fields, not valid Structured Fields, or that the sending implementation does not wish to send as Binary Item Types for some other reason.</t>
        <t>Note that Field Names are always serialised as String Literals (<xref target="literal" format="default"/>).</t>
        <t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Fields Types, and String Literals (<xref target="literal" format="default"/>) to their string counterparts.</t>
        <t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Item Types. In this case, the field types used are informed by the implementations knowledge of the individual field semantics; see <xref target="backport" format="default"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Fields are conveyed in BINHEADERS as String Literals (<xref target="literal" format="default"/>).</t>
        <t>Field values are stored in the HPACK <xref target="RFC7541" format="default"/> dynamic table without Huffman encoding, although specific Binary Item Types might specify the use of such encodings.</t>
        <t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Item Types; field names are encoded as they are in HPACK.</t>
      </section>
    </section>
    <section anchor="backport" numbered="true" toc="default">
      <name>Using Binary Structured Fields with Existing Fields</name>
      <t>Any field can potentially be parsed as a Structured Field according to the algorithms in <xref target="RFC8941" format="default"/> and serialised as a Binary Structured Field. However, many cannot, so optimistically parsing them can be expensive.</t>
      <t>This section identifies fields that will usually succeed in <xref target="direct" format="default"/>, and those that can be mapped into Structured Fields by using an alias field name in <xref target="aliased" format="default"/>.</t>
      <section anchor="direct" numbered="true" toc="default">
        <name>Directly Represented Fields</name>
        <t>The following HTTP field names can have their values parsed as Structured Fields according to the algorithms in <xref target="RFC8941" format="default"/>, and thus can usually be serialised using the corresponding Binary Item Types.</t>
        <t>When one of these fields' values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal" format="default"/>).</t>
        <ul spacing="normal">
          <li>Accept - List</li>
          <li>Accept-Encoding - List</li>
          <li>Accept-Language - List</li>
          <li>Accept-Patch - List</li>
          <li>Accept-Ranges - List</li>
          <li>Access-Control-Allow-Credentials - Item</li>
          <li>Access-Control-Allow-Headers - List</li>
          <li>Access-Control-Allow-Methods - List</li>
          <li>Access-Control-Allow-Origin - Item</li>
          <li>Access-Control-Max-Age - Item</li>
          <li>Access-Control-Request-Headers - List</li>
          <li>Access-Control-Request-Method - Item</li>
          <li>Age - Item</li>
          <li>Allow - List</li>
          <li>ALPN - List</li>
          <li>Alt-Svc - Dictionary</li>
          <li>Alt-Used - Item</li>
          <li>Cache-Control - Dictionary</li>
          <li>Connection - List</li>
          <li>Content-Encoding - List</li>
          <li>Content-Language - List</li>
          <li>Content-Length - Item</li>
          <li>Content-Type - Item</li>
          <li>Expect - Item</li>
          <li>Expect-CT - Dictionary</li>
          <li>Forwarded - Dictionary</li>
          <li>Host - Item</li>
          <li>Keep-Alive - Dictionary</li>
          <li>Origin - Item</li>
          <li>Pragma - Dictionary</li>
          <li>Prefer - Dictionary</li>
          <li>Preference-Applied - Dictionary</li>
          <li>Retry-After - Item  (see caveat below)</li>
          <li>Surrogate-Control - Dictionary</li>
          <li>TE - List</li>
          <li>Trailer - List</li>
          <li>Transfer-Encoding - List</li>
          <li>Vary - List</li>
          <li>X-Content-Type-Options - Item</li>
          <li>X-XSS-Protection - List</li>
        </ul>
        <t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal" format="default"/>).</t>
      </section>
      <section anchor="aliased" numbered="true" toc="default">
        <name>Aliased Fields</name>
        <t>The following HTTP field names can have their values represented in Structured Fields by mapping them into its data types and then serialising the resulting Structured Field using an alternative field name.</t>
        <t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork>
        <t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured Fields as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Date: 784072177
]]></artwork>
        <t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal" format="default"/>).</t>
        <t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate" format="default"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>
        <t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Fields.</t>
        <ul spacing="normal">
          <li>ISSUE: using separate names assures that the different syntax doesn't "leak" into normal fields, but it isn't strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn't understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></li>
        </ul>
        <section anchor="urls" numbered="true" toc="default">
          <name>URLs</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by considering their payload a string.</t>
          <ul spacing="normal">
            <li>Content-Location - SF-Content-Location</li>
            <li>Location - SF-Location</li>
            <li>Referer - SF-Referer</li>
          </ul>
          <t>For example, a (non-binary) Location:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Location: "https://example.com/foo"
]]></artwork>
          <t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>
        </section>
        <section anchor="dates" numbered="true" toc="default">
          <name>Dates</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by parsing their payload according to <xref target="RFC7230" format="default"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>
          <ul spacing="normal">
            <li>Date - SF-Date</li>
            <li>Expires - SF-Expires</li>
            <li>If-Modified-Since - SF-IMS</li>
            <li>If-Unmodified-Since - SF-IUS</li>
            <li>Last-Modified - SF-LM</li>
          </ul>
          <t>For example, a (non-binary) Expires:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Expires: 1571965240
]]></artwork>
        </section>
        <section anchor="etags" numbered="true" toc="default">
          <name>ETags</name>
          <t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Fields by representing the entity-tag as a string, and the weakness flag as a boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>
          <ul spacing="normal">
            <li>ETag - SF-ETag</li>
          </ul>
          <t>For example, a (non-Binary) ETag:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-ETag: "abcdef"; w=?1
]]></artwork>
          <t>If-None-Match is a list of the structure described above.</t>
          <ul spacing="normal">
            <li>If-None-Match - SF-INM</li>
          </ul>
          <t>For example, a (non-binary) If-None-Match:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork>
        </section>
        <section anchor="links" numbered="true" toc="default">
          <name>Links</name>
          <t>The field-value of the Link header field <xref target="RFC8288" format="default"/> can be represented in Binary Structured Fields by representing the URI-Reference as a string, and link-param as parameters.</t>
          <ul spacing="normal">
            <li>Link: SF-Link</li>
          </ul>
          <t>For example, a (non-binary) Link:</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork>
        </section>
        <section anchor="cookies" numbered="true" toc="default">
          <name>Cookies</name>
          <t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265" format="default"/> can be represented in Binary Structured Fields as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>
          <t>Set-Cookie: SF-Set-Cookie
Cookie: SF-Cookie</t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
SF-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SF-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork>
          <ul spacing="normal">
            <li>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></li>
            <li>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></li>
            <li>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></li>
          </ul>
        </section>
      </section>
    </section>
    <section anchor="iana-considerations" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <ul spacing="normal">
        <li>ISSUE: todo</li>
      </ul>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>
      <t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Fields data types, along with the "escape valve" of String Literals (<xref target="literal" format="default"/>). Therefore, implementation divergence from this strictness can have security impact.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>Normative References</name>
      <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
        <front>
          <title>Key words for use in RFCs to Indicate Requirement Levels</title>
          <author fullname="S. Bradner" initials="S." surname="Bradner">
            <organization/>
          </author>
          <date month="March" year="1997"/>
          <abstract>
            <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="2119"/>
        <seriesInfo name="DOI" value="10.17487/RFC2119"/>
      </reference>
      <reference anchor="I-D.ietf-quic-transport" target="https://www.ietf.org/archive/id/draft-ietf-quic-transport-34.txt">
        <front>
          <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
          <author fullname="Jana Iyengar">
            <organization>Fastly</organization>
          </author>
          <author fullname="Martin Thomson">
            <organization>Mozilla</organization>
          </author>
          <date day="14" month="January" year="2021"/>
          <abstract>
            <t>   This document defines the core of the QUIC transport protocol.  QUIC
   provides applications with flow-controlled streams for structured
   communication, low-latency connection establishment, and network path
   migration.  QUIC includes security measures that ensure
   confidentiality, integrity, and availability in a range of deployment
   circumstances.  Accompanying documents describe the integration of
   TLS for key negotiation, loss detection, and an exemplary congestion
   control algorithm.

DO NOT DEPLOY THIS VERSION OF QUIC

   DO NOT DEPLOY THIS VERSION OF QUIC UNTIL IT IS IN AN RFC.  This
   version is still a work in progress.  For trial deployments, please
   use earlier versions.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org (mailto:quic@ietf.org)), which is
   archived at https://mailarchive.ietf.org/arch/search/?email_list=quic

   Working Group information can be found at https://github.com/quicwg;
   source code and issues list for this draft can be found at
   https://github.com/quicwg/base-drafts/labels/-transport.

            </t>
          </abstract>
        </front>
        <seriesInfo name="Internet-Draft" value="draft-ietf-quic-transport-34"/>
      </reference>
      <reference anchor="RFC8941" target="https://www.rfc-editor.org/info/rfc8941">
        <front>
          <title>Structured Field Values for HTTP</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <author fullname="P-H. Kamp" initials="P-H." surname="Kamp">
            <organization/>
          </author>
          <date month="February" year="2021"/>
          <abstract>
            <t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header and trailer fields, known as "Structured Fields", "Structured Headers", or "Structured Trailers". It is intended for use by specifications of new HTTP fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8941"/>
        <seriesInfo name="DOI" value="10.17487/RFC8941"/>
      </reference>
      <reference anchor="RFC7541" target="https://www.rfc-editor.org/info/rfc7541">
        <front>
          <title>HPACK: Header Compression for HTTP/2</title>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="H. Ruellan" initials="H." surname="Ruellan">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7541"/>
        <seriesInfo name="DOI" value="10.17487/RFC7541"/>
      </reference>
      <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
        <front>
          <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
          <author fullname="B. Leiba" initials="B." surname="Leiba">
            <organization/>
          </author>
          <date month="May" year="2017"/>
          <abstract>
            <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
          </abstract>
        </front>
        <seriesInfo name="BCP" value="14"/>
        <seriesInfo name="RFC" value="8174"/>
        <seriesInfo name="DOI" value="10.17487/RFC8174"/>
      </reference>
      <reference anchor="RFC7540" target="https://www.rfc-editor.org/info/rfc7540">
        <front>
          <title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
          <author fullname="M. Belshe" initials="M." surname="Belshe">
            <organization/>
          </author>
          <author fullname="R. Peon" initials="R." surname="Peon">
            <organization/>
          </author>
          <author fullname="M. Thomson" initials="M." role="editor" surname="Thomson">
            <organization/>
          </author>
          <date month="May" year="2015"/>
          <abstract>
            <t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t>
            <t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7540"/>
        <seriesInfo name="DOI" value="10.17487/RFC7540"/>
      </reference>
      <reference anchor="RFC7230" target="https://www.rfc-editor.org/info/rfc7230">
        <front>
          <title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
          <author fullname="R. Fielding" initials="R." role="editor" surname="Fielding">
            <organization/>
          </author>
          <author fullname="J. Reschke" initials="J." role="editor" surname="Reschke">
            <organization/>
          </author>
          <date month="June" year="2014"/>
          <abstract>
            <t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="7230"/>
        <seriesInfo name="DOI" value="10.17487/RFC7230"/>
      </reference>
      <reference anchor="RFC8288" target="https://www.rfc-editor.org/info/rfc8288">
        <front>
          <title>Web Linking</title>
          <author fullname="M. Nottingham" initials="M." surname="Nottingham">
            <organization/>
          </author>
          <date month="October" year="2017"/>
          <abstract>
            <t>This specification defines a model for the relationships between resources on the Web ("links") and the type of those relationships ("link relation types").</t>
            <t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="8288"/>
        <seriesInfo name="DOI" value="10.17487/RFC8288"/>
      </reference>
      <reference anchor="RFC6265" target="https://www.rfc-editor.org/info/rfc6265">
        <front>
          <title>HTTP State Management Mechanism</title>
          <author fullname="A. Barth" initials="A." surname="Barth">
            <organization/>
          </author>
          <date month="April" year="2011"/>
          <abstract>
            <t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t>
          </abstract>
        </front>
        <seriesInfo name="RFC" value="6265"/>
        <seriesInfo name="DOI" value="10.17487/RFC6265"/>
      </reference>
    </references>
    <section anchor="data-supporting-directly-represented-field-mappings" numbered="true" toc="default">
      <name>Data Supporting Directly Represented Field Mappings</name>
      <t><em>RFC EDITOR: please remove this section before publication</em></t>
      <t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Fields using the types listed in <xref target="direct" format="default"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>
      <ul spacing="normal">
        <li>accept: 9,198 / 10 = 0.109%</li>
        <li>accept-encoding: 34,157 / 74 = 0.216%</li>
        <li>accept-language: 381,034 / 512 = 0.134%</li>
        <li>accept-patch: 5 / 0 = 0.000%</li>
        <li>accept-ranges: 197,746,643 / 3,960 = 0.002%</li>
        <li>access-control-allow-credentials: 16,684,916 / 7,438 = 0.045%</li>
        <li>access-control-allow-headers: 12,976,838 / 15,074 = 0.116%</li>
        <li>access-control-allow-methods: 15,466,748 / 28,203 = 0.182%</li>
        <li>access-control-allow-origin: 105,307,402 / 271,359 = 0.257%</li>
        <li>access-control-max-age: 5,284,663 / 7,754 = 0.147%</li>
        <li>access-control-request-headers: 39,328 / 624 = 1.562%</li>
        <li>access-control-request-method: 146,259 / 13,821 = 8.634%</li>
        <li>age: 71,281,684 / 172,398 = 0.241%</li>
        <li>allow: 351,704 / 1,886 = 0.533%</li>
        <li>alt-svc: 19,775,126 / 15,680,528 = 44.226%</li>
        <li>cache-control: 264,805,256 / 782,896 = 0.295%</li>
        <li>connection: 105,876,072 / 2,915 = 0.003%</li>
        <li>content-encoding: 139,799,523 / 379 = 0.000%</li>
        <li>content-language: 2,367,162 / 728 = 0.031%</li>
        <li>content-length: 296,624,718 / 787,843 = 0.265%</li>
        <li>content-type: 341,918,716 / 795,676 = 0.232%</li>
        <li>expect: 0 / 47 = 100.000%</li>
        <li>expect-ct: 26,569,605 / 29,114 = 0.109%</li>
        <li>forwarded: 119 / 35 = 22.727%</li>
        <li>host: 25,333 / 1,441 = 5.382%</li>
        <li>keep-alive: 43,061,546 / 796 = 0.002%</li>
        <li>origin: 24,335 / 1,539 = 5.948%</li>
        <li>pragma: 46,820,588 / 81,700 = 0.174%</li>
        <li>preference-applied: 57 / 0 = 0.000%</li>
        <li>retry-after: 605,844 / 6,195 = 1.012%</li>
        <li>strict-transport-security: 26,825,957 / 35,258,808 = 56.791%</li>
        <li>surrogate-control: 121,118 / 861 = 0.706%</li>
        <li>te: 1 / 0 = 0.000%</li>
        <li>trailer: 282 / 0 = 0.000%</li>
        <li>transfer-encoding: 13,952,661 / 0 = 0.000%</li>
        <li>vary: 150,787,199 / 41,313 = 0.027%</li>
        <li>x-content-type-options: 99,968,016 / 208,885 = 0.209%</li>
        <li>x-xss-protection: 79,871,948 / 362,979 = 0.452%</li>
      </ul>
      <t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>
      <t><tt>alt-svc</tt> has a high failure rate because some currently-used ALPN tokens (e.g., <tt>h3-Q43</tt>) do not conform to key's syntax. Since the final version of HTTP/3 will use the <tt>h3</tt> token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.</t>
      <t><tt>forwarded</tt> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <tt>for=192.168.1.1</tt>.</t>
      <t><tt>strict-transport-security</tt> has a high failure rate because the <tt>includeSubDomains</tt> flag does not conform to the key syntax.</t>
      <t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>
      <ul spacing="normal">
        <li>date: 354,652,447</li>
        <li>server: 311,275,961</li>
        <li>last-modified: 263,832,615</li>
        <li>expires: 199,967,042</li>
        <li>status: 192,423,509</li>
        <li>etag: 172,058,269</li>
        <li>timing-allow-origin: 64,407,586</li>
        <li>x-cache: 41,740,804</li>
        <li>p3p: 39,490,058</li>
        <li>x-frame-options: 34,037,985</li>
      </ul>
    </section>
  </back>
  <!-- ##markdown-source:
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

-->

</rfc>
