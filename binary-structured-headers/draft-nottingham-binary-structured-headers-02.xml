<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.13 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-01" category="std">

  <front>
    <title>Binary Structured HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="headers"/>, and specifies its use in HTTP/2 – specifically, as part of HPACK Literal Header Field Representations (<xref target="RFC7541"/>) – in <xref target="negotiate"/>.</t>

<t><xref target="backport"/> defines how to use Structured Headers for many existing headers when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="headers" title="Binary Structured Headers">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>The types permissable as the top-level of Structured Header field values – Dictionary, List, and Item – are defined in terms of a Binary Literal Representation (<xref target="binlit"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541"/>.</t>

<t>Binary representations of the remaining types are defined in <xref target="leaf"/>.</t>

<section anchor="binlit" title="The Binary Literal Representation">

<t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame"/>).</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   Type (4)    | PLength (4+)  |
+---+---------------------------+
| Payload Data (Length octets)  |
+-------------------------------+
]]></artwork></figure>

<t>A binary literal representation contains the following fields:</t>

<t><list style="symbols">
  <t>Type: Four bits indicating the type of the payload.</t>
  <t>PLength: The number of octets used to represent the payload, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 4-bit prefix.</t>
  <t>Payload Data: The payload, as per below.</t>
</list></t>

<t>The following payload types are defined:</t>

<section anchor="lists" title="Lists">

<t>List values (type=0x1) have a payload consisting of a stream of Binary Structured Types representing the members of the list. Members that are Items are represented as per <xref target="inner-item"/>; members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="dictionaries" title="Dictionaries">

<t>Dictionary values (type=0x2) have a payload consisting of a stream of members.</t>

<t>Each member is represented by a key length, followed by that many bytes of the member-name, followed by Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  member-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| member-value
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the member-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>member-name: KL octets of the member-name</t>
  <t>member-value: One or more Binary Structure Types</t>
</list></t>

<t>member-values that are Items are represented as per <xref target="inner-item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="items" title="Items">

<t>Item values (type=0x3) have a payload consisting of Binary Structured Types, as described in <xref target="inner-item"/>.</t>

</section>
<section anchor="literal" title="String Literals">

<t>String Literals (type=0x4) are the string value of a header field; they are used to carry header field values that are not Binary Structured Headers, and may not be Structured Headers at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541"/>, Section 5.2.</t>

<t>Their payload is the octets of the field value.</t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
</section>
<section anchor="leaf" title="Binary Structured Types">

<t>Every Binary Structured Type starts with a 5-bit type field that identifies the format of its payload:</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
      Type (5)      |  Payload...
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Some Binary Structured Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x1) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Members (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the members, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Members: L octets</t>
</list></t>

<t>Each member of the list will be represented as an Item (<xref target="inner-item"/>); if any member cannot, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>The inner list’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the inner list.</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x2) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Parameters (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Parameters: L octets</t>
</list></t>

<t>Each parameter is represented by key length, followed by that many bytes of the parameter-name, followed by a Binary Structured Type representing the parameter-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  parameter-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| parameter-value (VL octets)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>parameter-name: KL octets of the parameter-name</t>
  <t>parameter-value: A Binary Structured type representing a bare item (<xref target="inner-item"/>)</t>
</list></t>

<t>Parameter-values are bare items; that is, they MUST NOT have parameters themselves.</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>Parameters are always associated with the Binary Structured Type that immediately preceded them. If parameters are not explicitly allowed on the preceding type, or there is no preceding type, it is an error.</t>

<t>ISSUE: use Huffman coding for parameter-name? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="inner-item" title="Item Payload Types">

<t>Individual Structured Header Items can be represented using the Binary Payload Types defined below.</t>

<t>The item’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the item.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x3) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |  Integer (2+)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix</t>
</list></t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x4) have a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |   Integer (2+)
+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  FLength (8+)
+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  Fractional (8+)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix.</t>
  <t>Fractional: The fractional component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix.</t>
</list></t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x5) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  String (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the string, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>String: L octets.</t>
</list></t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x6) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Token (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Token: L octets.</t>
</list></t>

<t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Byte Sequence (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Byte Sequence: L octets.</t>
</list></t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0x8) has a payload of two bits:</t>

<figure><artwork><![CDATA[
  5   6   7
+---+---+---+
  B |   X   |
+---+---+---+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. X is padding.</t>

</section>
</section>
</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the Binary Structured Types defined in <xref target="headers"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit"/>.</t>

<t>Fields that are Structured Headers can have their values represented using the Binary Literal Representation corresponding to that header’s top-level type – List, Dictionary, or Item; their values will then be serialised as a stream of Binary Structured Types.</t>

<t>Additionally, any field (including those defined as Structured Headers) can be serialised as a String Literal (<xref target="literal"/>), which accommodates headers that are not defined as Structured Headers, not valid Structured Headers, or that the sending implementation does not wish to send as Binary Structured Types for some other reason.</t>

<t>Note that Field Names are always serialised as String Literals (<xref target="literal"/>).</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and String Literals (<xref target="literal"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as String Literals (<xref target="literal"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - Dictionary</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Connection - List</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Expect-CT - Dictionary</t>
  <t>Forwarded - Dictionary</t>
  <t>Host - Item</t>
  <t>Keep-Alive - Dictionary</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
  <t>X-XSS-Protection - List</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<t>ISSUE: using separate names assures that the different syntax doesn’t “leak” into normal headers, but it isn’t strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn’t understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref>
ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref>
ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>ISSUE: todo</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of String Literals (<xref target="literal"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='October' day='31' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-14' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-14.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>



<section anchor="data-supporting-directly-represented-field-mappings" title="Data Supporting Directly Represented Field Mappings">

<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref>, representing more than 400,000,000 HTTP exchanges, were parsed as Structured Headers using the types listed in <xref target="direct"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>

<t><list style="symbols">
  <t>accept: 10060 / 8 = 0%</t>
  <t>accept-encoding: 37322 / 4 = 0%</t>
  <t>accept-language: 216051 / 199 = 0%</t>
  <t>accept-patch: 3 / 0 = 0%</t>
  <t>accept-ranges: 277520850 / 240940 = 0%</t>
  <t>access-control-allow-credentials: 17305094 / 16503 = 0%</t>
  <t>access-control-allow-headers: 10829889 / 19028 = 0%</t>
  <t>access-control-allow-methods: 15706123 / 12994 = 0%</t>
  <t>access-control-allow-origin: 79694513 / 209447 = 0%</t>
  <t>access-control-max-age: 5166126 / 9236 = 0%</t>
  <t>access-control-request-headers: 48937 / 532 = 1%</t>
  <t>access-control-request-method: 151702 / 12859 = 7%</t>
  <t>age: 222024968 / 417140 = 0%</t>
  <t>allow: 398227 / 567 = 0%</t>
  <t>alt-svc: 26793600 / 1779280 = 6%</t>
  <t>cache-control: 373807306 / 4119381 = 1%</t>
  <t>connection: 188382722 / 244317 = 0%</t>
  <t>content-encoding: 301904345 / 23368 = 0%</t>
  <t>content-language: 152252635 / 81760 = 0%</t>
  <t>content-length: 367973320 / 209032 = 0%</t>
  <t>content-type: 398500045 / 432427 = 0%</t>
  <t>expect: 0 / 1 = 100%</t>
  <t>expect-ct: 26129601 / 30226 = 0%</t>
  <t>forwarded: 23 / 59 = 71%</t>
  <t>host: 23003 / 781 = 3%</t>
  <t>keep-alive: 2 / 0 = 0%</t>
  <t>origin: 27921 / 1677 = 5%</t>
  <t>pragma: 219160866 / 890328 = 0%</t>
  <t>preference-applied: 2 / 59 = 96%</t>
  <t>retry-after: 680494 / 2832 = 0%</t>
  <t>surrogate-control: 156370 / 736 = 0%</t>
  <t>trailer: 1 / 0 = 0%</t>
  <t>transfer-encoding: 127553768 / 458 = 0%</t>
  <t>vary: 310245980 / 866776 = 0%</t>
  <t>x-content-type-options: 94309348 / 608045 = 0%</t>
  <t>x-xss-protection: 72910239 / 348566 = 0%</t>
</list></t>

<t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>

<t>Some failure rates are slightly raised because of a bug in the input data (see <eref target="https://discuss.httparchive.org/t/working-with-csv-dumps/1835">https://discuss.httparchive.org/t/working-with-csv-dumps/1835</eref>).</t>

<t><spanx style="verb">preference-applied</spanx> has a high failure rate because of the occurence of ‘.’ in keys (e.g., <spanx style="verb">odata.include-annotations</spanx>)</t>

<t><spanx style="verb">forwarded</spanx> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <spanx style="verb">for=192.168.1.1</spanx></t>

<t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>

<t><list style="symbols">
  <t>date: 405374834</t>
  <t>server: 367671207</t>
  <t>expires: 326515189</t>
  <t>last-modified: 325777639</t>
  <t>etag: 271541372</t>
  <t>location: 180398510</t>
  <t>via: 179060017</t>
  <t>x-powered-by: 178075863</t>
  <t>status: 169014311</t>
  <t>content-location: 126069665</t>
</list></t>

</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

