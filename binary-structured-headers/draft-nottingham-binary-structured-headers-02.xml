<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.13 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-binary-structured-headers-02" category="std">

  <front>
    <title>Binary Structured HTTP Headers</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This specification defines a binary serialisation of Structured Headers for HTTP, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/binary-structured-headers">https://github.com/mnot/I-D/labels/binary-structured-headers</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/binary-structured-headers/">https://mnot.github.io/I-D/binary-structured-headers/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers">https://github.com/mnot/I-D/commits/gh-pages/binary-structured-headers</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/">https://datatracker.ietf.org/doc/draft-nottingham-binary-structured-headers/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those structures in <xref target="headers"/>, and specifies its use in HTTP/2 – specifically, as part of HPACK Literal Header Field Representations (<xref target="RFC7541"/>) – in <xref target="negotiate"/>.</t>

<t><xref target="backport"/> defines how to use Structured Headers for many existing headers when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a more compact wire format in common situations. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="headers" title="Binary Structured Headers">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>The types permissable as the top-level of Structured Header field values – Dictionary, List, and Item – are defined in terms of a Binary Literal Representation (<xref target="binlit"/>), which is a replacement for the String Literal Representation in <xref target="RFC7541"/>.</t>

<t>Binary representations of the remaining types are defined in <xref target="leaf"/>.</t>

<section anchor="binlit" title="The Binary Literal Representation">

<t>The Binary Literal Representation is a replacement for the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, for use in BINHEADERS frames (<xref target="frame"/>).</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
|   Type (4)    | PLength (4+)  |
+---+---------------------------+
| Payload Data (Length octets)  |
+-------------------------------+
]]></artwork></figure>

<t>A binary literal representation contains the following fields:</t>

<t><list style="symbols">
  <t>Type: Four bits indicating the type of the payload.</t>
  <t>PLength: The number of octets used to represent the payload, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 4-bit prefix.</t>
  <t>Payload Data: The payload, as per below.</t>
</list></t>

<t>The following payload types are defined:</t>

<section anchor="lists" title="Lists">

<t>List values (type=0x1) have a payload consisting of a stream of Binary Structured Types representing the members of the list. Members that are Items are represented as per <xref target="inner-item"/>; members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="dictionaries" title="Dictionaries">

<t>Dictionary values (type=0x2) have a payload consisting of a stream of members.</t>

<t>Each member is represented by a key length, followed by that many bytes of the member-name, followed by Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  member-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| member-value
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the member-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>member-name: KL octets of the member-name</t>
  <t>member-value: One or more Binary Structure Types</t>
</list></t>

<t>member-values that are Items are represented as per <xref target="inner-item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If any member cannot be represented, the entire field value MUST be serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="items" title="Items">

<t>Item values (type=0x3) have a payload consisting of Binary Structured Types, as described in <xref target="inner-item"/>.</t>

</section>
<section anchor="literal" title="String Literals">

<t>String Literals (type=0x4) are the string value of a header field; they are used to carry header field values that are not Binary Structured Headers, and may not be Structured Headers at all. As such, their semantics are that of String Literal Representations in <xref target="RFC7541"/>, Section 5.2.</t>

<t>Their payload is the octets of the field value.</t>

<t><list style="symbols">
  <t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>
</list></t>

</section>
</section>
<section anchor="leaf" title="Binary Structured Types">

<t>Every Binary Structured Type starts with a 5-bit type field that identifies the format of its payload:</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
      Type (5)      |  Payload...
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Some Binary Structured Types contain padding bits; senders MUST set padding bits to 0; recipients MUST ignore their values.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x1) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Members (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the members, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Members: L octets</t>
</list></t>

<t>Each member of the list will be represented as an Item (<xref target="inner-item"/>); if any member cannot, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>The inner list’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the inner list.</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x2) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Parameters (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix</t>
  <t>Parameters: L octets</t>
</list></t>

<t>Each parameter is represented by key length, followed by that many bytes of the parameter-name, followed by a Binary Structured Type representing the parameter-value.</t>

<figure><artwork><![CDATA[
  0   1   2   3   4   5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
| KL (8+)                       |  parameter-name (KL octets)
+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
| parameter-value (VL octets)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>A parameter’s fields are:</t>

<t><list style="symbols">
  <t>KL: The number of octets used to represent the parameter-name, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix</t>
  <t>parameter-name: KL octets of the parameter-name</t>
  <t>parameter-value: A Binary Structured type representing a bare item (<xref target="inner-item"/>)</t>
</list></t>

<t>Parameter-values are bare items; that is, they MUST NOT have parameters themselves.</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a String Literal (<xref target="literal"/>).</t>

<t>Parameters are always associated with the Binary Structured Type that immediately preceded them. If parameters are not explicitly allowed on the preceding type, or there is no preceding type, it is an error.</t>

<t><list style="symbols">
  <t>ISSUE: use Huffman coding for parameter-name? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>
</list></t>

</section>
<section anchor="inner-item" title="Item Payload Types">

<t>Individual Structured Header Items can be represented using the Binary Payload Types defined below.</t>

<t>The item’s parameters, if present, are serialised in a following Parameter type (<xref target="parameter"/>); they do not form part of the payload of the item.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x3) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |  Integer (2+)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix</t>
</list></t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x4) have a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
  S |   Integer (2+)
+---+---+---+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  FLength (8+)
+---+---+---+---+---+---+---+---

  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---
|  Fractional (8+)
+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S: sign bit; 0 is negative, 1 is positive</t>
  <t>Integer: The integer component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 2-bit prefix.</t>
  <t>Fractional: The fractional component, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 8-bit prefix.</t>
</list></t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x5) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  String (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the string, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>String: L octets.</t>
  <t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>
</list></t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x6) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Token (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the token, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Token: L octets.</t>
  <t>ISSUE: use Huffman coding? <eref target="https://github.com/mnot/I-D/issues/305">https://github.com/mnot/I-D/issues/305</eref></t>
</list></t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x7) has a payload in the format:</t>

<figure><artwork><![CDATA[
  5   6   7   0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+---+---+---
     L(3+)  |  Byte Sequence (L octets)
+---+---+---+---+---+---+---+---+---+---+---
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>L: The number of octets used to represent the byte sequence, encoded as per <xref target="RFC7541"/>, Section 5.1, with a 3-bit prefix.</t>
  <t>Byte Sequence: L octets.</t>
</list></t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0x8) has a payload of two bits:</t>

<figure><artwork><![CDATA[
  5   6   7
+---+---+---+
  B |   X   |
+---+---+---+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. X is padding.</t>

</section>
</section>
</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the Binary Structured Types defined in <xref target="headers"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; instead of using the String Literal Representation defined in <xref target="RFC7541"/>, Section 5.2, it uses the Binary Literal Representation defined in <xref target="binlit"/>.</t>

<t>Fields that are Structured Headers can have their values represented using the Binary Literal Representation corresponding to that header’s top-level type – List, Dictionary, or Item; their values will then be serialised as a stream of Binary Structured Types.</t>

<t>Additionally, any field (including those defined as Structured Headers) can be serialised as a String Literal (<xref target="literal"/>), which accommodates headers that are not defined as Structured Headers, not valid Structured Headers, or that the sending implementation does not wish to send as Binary Structured Types for some other reason.</t>

<t>Note that Field Names are always serialised as String Literals (<xref target="literal"/>).</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and String Literals (<xref target="literal"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as String Literals (<xref target="literal"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - Dictionary</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Connection - List</t>
  <t>Content-Encoding - List</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Expect-CT - Dictionary</t>
  <t>Forwarded - Dictionary</t>
  <t>Host - Item</t>
  <t>Keep-Alive - Dictionary</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
  <t>X-XSS-Protection - List</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a String Literal (<xref target="literal"/>).</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a String Literal (<xref target="literal"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<t><list style="symbols">
  <t>ISSUE: using separate names assures that the different syntax doesn’t “leak” into normal headers, but it isn’t strictly necessary if implementations always convert back to the correct form when giving it to peers or consuming software that doesn’t understand this. <eref target="https://github.com/mnot/I-D/issues/307">https://github.com/mnot/I-D/issues/307</eref></t>
</list></t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t><list style="symbols">
  <t>ISSUE: explicitly convert Expires to an integer? <eref target="https://github.com/mnot/I-D/issues/308">https://github.com/mnot/I-D/issues/308</eref></t>
  <t>ISSUE: dictionary keys cannot contain UC alpha. <eref target="https://github.com/mnot/I-D/issues/312">https://github.com/mnot/I-D/issues/312</eref></t>
  <t>ISSUE: explicitly allow non-string content. <eref target="https://github.com/mnot/I-D/issues/313">https://github.com/mnot/I-D/issues/313</eref></t>
</list></t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t><list style="symbols">
  <t>ISSUE: todo</t>
</list></t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of String Literals (<xref target="literal"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='January' day='28' year='2020' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-15' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-15.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>



<section anchor="data-supporting-directly-represented-field-mappings" title="Data Supporting Directly Represented Field Mappings">

<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>To help guide decisions about Directly Represented Fields, the HTTP response headers captured by the HTTP Archive <eref target="https://httparchive.org">https://httparchive.org</eref> in February 2020, representing more than 350,000,000 HTTP exchanges, were parsed as Structured Headers using the types listed in <xref target="direct"/>, with the indicated number of successful header instances, failures, and the resulting failure rate:</t>

<t><list style="symbols">
  <t>accept: 9201 / 10 = 0.109%</t>
  <t>accept-encoding: 34158 / 74 = 0.216%</t>
  <t>accept-language: 381037 / 512 = 0.134%</t>
  <t>accept-patch: 5 / 0 = 0.000%</t>
  <t>accept-ranges: 197759320 / 3960 = 0.002%</t>
  <t>access-control-allow-credentials: 16692270 / 2436 = 0.015%</t>
  <t>access-control-allow-headers: 13008501 / 15317 = 0.118%</t>
  <t>access-control-allow-methods: 15469948 / 28203 = 0.182%</t>
  <t>access-control-allow-origin: 105462779 / 131851 = 0.125%</t>
  <t>access-control-max-age: 5287424 / 7588 = 0.143%</t>
  <t>access-control-request-headers: 39340 / 624 = 1.561%</t>
  <t>access-control-request-method: 146566 / 13822 = 8.618%</t>
  <t>age: 71292663 / 168452 = 0.236%</t>
  <t>allow: 351707 / 1886 = 0.533%</t>
  <t>alt-svc: 19777530 / 18743564 = 48.658%</t>
  <t>cache-control: 264666876 / 946434 = 0.356%</t>
  <t>connection: 105884722 / 2915 = 0.003%</t>
  <t>content-encoding: 139812089 / 379 = 0.000%</t>
  <t>content-language: 2368912 / 728 = 0.031%</t>
  <t>content-length: 296649810 / 787897 = 0.265%</t>
  <t>content-type: 341978677 / 764712 = 0.223%</t>
  <t>expect: 0 / 47 = 100.000%</t>
  <t>expect-ct: 26573905 / 29117 = 0.109%</t>
  <t>forwarded: 119 / 35 = 22.727%</t>
  <t>host: 25433 / 1343 = 5.016%</t>
  <t>origin: 24339 / 1536 = 5.936%</t>
  <t>pragma: 46826446 / 81707 = 0.174%</t>
  <t>preference-applied: 57 / 0 = 0.000%</t>
  <t>retry-after: 605928 / 6192 = 1.012%</t>
  <t>strict-transport-security: 26826044 / 35266879 = 56.797%</t>
  <t>surrogate-control: 121124 / 861 = 0.706%</t>
  <t>te: 1 / 0 = 0.000%</t>
  <t>trailer: 282 / 0 = 0.000%</t>
  <t>transfer-encoding: 13953547 / 0 = 0.000%</t>
  <t>vary: 150802211 / 41317 = 0.027%</t>
  <t>x-content-type-options: 99997237 / 188888 = 0.189%</t>
  <t>x-xss-protection: 79878788 / 362990 = 0.452%</t>
</list></t>

<t>This data set focuses on response headers, although some request headers are present (because, the Web).</t>

<t><spanx style="verb">alt-svc</spanx> has a high failure rate because some currently-used ALPN tokens (e.g., <spanx style="verb">h3-Q43</spanx>) do not conform to key’s syntax. Since the final version of HTTP/3 will use the <spanx style="verb">h3</spanx> token, this shouldn’t be a long-term issue, although future tokens may again violate this assumption.</t>

<t><spanx style="verb">forwarded</spanx> has a high failure rate because many senders use the unquoted form for IP addresses, which makes integer parsing fail; e.g., <spanx style="verb">for=192.168.1.1</spanx>.</t>

<t><spanx style="verb">strict-transport-security</spanx> has a high failure rate because the <spanx style="verb">includeSubDomains</spanx> flag does not conform to the key syntax.</t>

<t>The top ten header fields in that data set that were not parsed as Directly Represented Fields are:</t>

<t><list style="symbols">
  <t>date: 354682923</t>
  <t>server: 311299092</t>
  <t>last-modified: 263851521</t>
  <t>expires: 199985746</t>
  <t>status: 192439616</t>
  <t>etag: 172071631</t>
  <t>timing-allow-origin: 64413795</t>
  <t>x-cache: 41743980</t>
  <t>p3p: 39518705</t>
  <t>x-frame-options: 34045384</t>
</list></t>

</section>


  </back>

<!-- ##markdown-source:
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
ssltqMQwlw6g69udVr+NRXr/Dwe4cL6jZQAA

-->

</rfc>

