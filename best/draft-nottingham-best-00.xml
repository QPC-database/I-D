<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-best-00" category="std">

  <front>
    <title>Binary Encoding of Structured Types</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of these types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/hehe">https://github.com/mnot/I-D/labels/hehe</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/hehe/">https://mnot.github.io/I-D/hehe/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/hehe">https://github.com/mnot/I-D/commits/gh-pages/hehe</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-hehe/">https://datatracker.ietf.org/doc/draft-nottingham-hehe/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of these types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2. It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>

<t>The goals of this specification are to reduce parsing overhead and associated costs. It may also result in a more efficient wire format in some cases, but that is not a primary goal. An additional goal is to enable future work on more efficient header compression mechanisms.</t>

<t><xref target="types"/> defines binary serialisations of Structured Headers types. <xref target="negotiate"/> shows how to negotiate their use in a HTTP/2 connection. <xref target="backport"/> shows how to use Structured Headers types with already defined header fields.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="types" title="Binary Structured Types">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</t>

<figure><artwork><![CDATA[
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
]]></artwork></figure>

<t>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</t>

<section anchor="list" title="Lists">

<t>The List data type (type=0x1) has a length field that indicates how many members are in the list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented by one or more Binary Structured Types (depending on their types), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value <xref target="TFV"/>.</t>

<t>list-members that are Items are represented as per <xref target="item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>Binary Structured Headers can represent Lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x2) has a length field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented as an Item <xref target="item"/>, unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value <xref target="TFV"/>.</t>

<t>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x3) has a length field that indicates how many (parameter-name, parameter-value) pairs are present, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Parameters...
--+--------+--------+---------
]]></artwork></figure>

<t>Each pair will be represented by at least two Binary Structured Types; the parameter-name, represented as a token <xref target="token"/>, and the parameter-value, which is represented as a bare item <xref target="item"/>.</t>

<t>If the parameters cannot be represented, the field value will be serialised as a Textual Field Value <xref target="TFV"/>.</t>

<t>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

</section>
</section>
<section anchor="dictionaries" title="Dictionaries">

<t>The Dictionary data type (type=0x4) has a length field that indicates how many members are in the dictionary, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Dictionary members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the dictionary will be represented by at least two Binary Structured Types; the member-name, represented as a token <xref target="token"/>, and the member-value, which is represented as one or more Binary Structured Types as per their definitions.</t>

<t>member-values that are Items are represented as per <xref target="item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If the dictionary cannot be represented, the field value will be serialised as a Textual Field Value <xref target="TFV"/>.</t>

<t>Binary Structured Headers can represent Dictionaries with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

</section>
<section anchor="item" title="Items">

<t>Items are represented using one to many Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</t>

<t>The item’s parameters, if present, are serialised as the Parameter type <xref target="parameter"/> (which will include zero or more following types).</t>

<t>Bare items are never serialised with parameters.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x5) has a payload of 58 bits:</t>

<figure><artwork><![CDATA[
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>X - 1 bit; discard</t>
  <t>Integer - 50 bits, unsigned</t>
  <t>Pad - 6 bits</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x6) have a payload of 74 bits:</t>

<figure><artwork><![CDATA[
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>Integer - 47 bits, unsigned</t>
  <t>Fractional - 20 bits, unsigned integer</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
]]></artwork></figure>

<t>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values <xref target="TFV"/>.</t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0xa) has a payload of two bits:</t>

<figure><artwork><![CDATA[
--+
BX|
--+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. The value of X is discarded.</t>

</section>
</section>
<section anchor="TFV" title="Textual Field Values">

<t>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</t>

<t>Its payload is two bytes of padding, followed by the octets of the field value:</t>

<figure><artwork><![CDATA[
--+--------+----
XX| Field Value...
--+--------+----
]]></artwork></figure>

<t>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</t>

<t>TODO: huffman coding?</t>

</section>
</section>
<section anchor="negotiate" title="Negotiating and Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can advertise this and then take advantage of that knowledge to serialise headers that they know to be compatible with</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the encoding of Binary Structured Headers defined in <xref target="types"/>.</t>
  <t>The peer will process HEADERS frames containing the HEADERS indicator as defined in <xref target="indicator"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into an encoding it does understand (typically, the textual Structured Headers defined in <xref target="I-D.ietf-httpbis-header-structure"/>) where necessary.</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields <xref target="aliased"/> into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="indicator" title="HEADERS Indicator">

<t>When a peer has indicated that it supports this specification {#setting}, a sender indicates that a given HEADERS frame is serialising all of the fields in a header block fragment (<xref target="RFC7540"/> Section 6.2) as Binary Structured Types by prefixing the header block fragment with the byte 0x80 (i.e., 10000000, which is an illegal indexed header field reference in HPACK <xref target="RFC7541"/>).</t>

<t>Such header block fragments will serialise all field values as Binary Structured Types (possibly using Textual Field Values <xref target="TFV"/>). These field values can be indexed in the dynamic table just as “normal” field values, although they may have to be converted to textual field values upon reuse, depending upon the capabilities of the peer at that time.</t>

<t>Binary Structured Types do not have Huffman encoding applied to them (except as specified in their definitions).</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value <xref target="TFV"/>.</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value <xref target="TFV"/>.</t>

<t>TODO: Accept and Content-Type media types use + in values.</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value <xref target="TFV"/>.</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>TODO: explicitly convert Expires to an integer?</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values <xref target="TFV"/>. Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='August' day='25' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-13.txt' />
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>

    <references title='Informative References'>





<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>




    </references>



  </back>

<!-- ##markdown-source:
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

-->

</rfc>

