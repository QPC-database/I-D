<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-best-00" category="std">

  <front>
    <title>Binary Encoding of Structured Types</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields as ASCII strings. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP defines a set of data types that new headers can use to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/best">https://github.com/mnot/I-D/labels/best</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/best/">https://mnot.github.io/I-D/best/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/best">https://github.com/mnot/I-D/commits/gh-pages/best</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-best/">https://datatracker.ietf.org/doc/draft-nottingham-best/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations <xref target="RFC7541"/>.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<t><xref target="types"/> defines binary serialisations of Structured Headers types. <xref target="negotiate"/> shows how to negotiate their use in a HTTP/2 connection. <xref target="backport"/> shows how to use Structured Headers types with already defined header fields.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="types" title="Binary Structured Types">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</t>

<figure><artwork><![CDATA[
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
]]></artwork></figure>

<t>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</t>

<section anchor="list" title="Lists">

<t>The List data type (type=0x1) has a payload consisting of one or more members.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented by one or more Binary Structured Types (depending on their types), unless it cannot be represented; in these cases, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>list-members that are Items are represented as per <xref target="item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>Binary Structured Headers can represent Lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x2) has a length field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented as an Item (<xref target="item"/>), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x3) has a length field that indicates how many (parameter-name, parameter-value) pairs are present, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Parameters...
--+--------+--------+---------
]]></artwork></figure>

<t>Each pair will be represented by at least two Binary Structured Types; the parameter-name, represented as a token (<xref target="token"/>), and the parameter-value, which is represented as a bare item (<xref target="item"/>).</t>

<t>If the parameters cannot be represented, the entire field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
</section>
<section anchor="dictionaries" title="Dictionaries">

<t>The Dictionary data type (type=0x4) has a payload consisting of member-name / member-value pairs.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
  Dictionary members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the dictionary is represented by an 8-bit key length field KL, followed by that many bytes of the member-name, followed by one or more Binary Structured Types representing the member-value.</t>

<figure><artwork><![CDATA[
+--------+--------+---------
|  KL(8) | member-name(*) member-value...
+--------+--------+---------
]]></artwork></figure>

<t>member-values that are Items are represented as per <xref target="item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If the dictionary cannot be represented, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

</section>
<section anchor="item" title="Items">

<t>Items are represented using one to many Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</t>

<t>The item’s parameters, if present, are serialised as the Parameter type (<xref target="parameter"/>), which will include zero or more following types.</t>

<t>Bare items are never serialised with parameters.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x5) has a payload of 58 bits:</t>

<figure><artwork><![CDATA[
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>X - 1 bit; discard</t>
  <t>Integer - 50 bits, unsigned</t>
  <t>Pad - 6 bits</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x6) have a payload of 74 bits:</t>

<figure><artwork><![CDATA[
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>Integer - 47 bits, unsigned</t>
  <t>Fractional - 20 bits, unsigned integer</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
]]></artwork></figure>

<t>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0xa) has a payload of two bits:</t>

<figure><artwork><![CDATA[
--+
BX|
--+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. The value of X is discarded.</t>

</section>
</section>
<section anchor="TFV" title="Textual Field Values">

<t>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</t>

<t>Its payload is two bytes of padding, followed by the octets of the field value:</t>

<figure><artwork><![CDATA[
--+--------+----
XX| Field Value...
--+--------+----
]]></artwork></figure>

<t>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</t>

<t>TODO: huffman coding?</t>

</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the encoding of Binary Structured Headers defined in <xref target="types"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send Binary Structured Headers in the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; the field values encoded in the Header Block Fragment as Literal Header Field representations are Binary Structured Headers.</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and Textual Field Values (<xref target="TFV"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as Textual Field Values (<xref target="TFV"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>TODO: Accept and Content-Type media types use + in values.</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>TODO: explicitly convert Expires to an integer?</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values (<xref target="TFV"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='August' day='25' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-13.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
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

-->

</rfc>

