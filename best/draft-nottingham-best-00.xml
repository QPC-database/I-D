<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-best-00" category="std">

  <front>
    <title>Binary Encoding of Structured Types</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields as ASCII strings. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP defines a set of data types that new headers can use to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/best">https://github.com/mnot/I-D/labels/best</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/best/">https://mnot.github.io/I-D/best/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/best">https://github.com/mnot/I-D/commits/gh-pages/best</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-best/">https://datatracker.ietf.org/doc/draft-nottingham-best/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations <xref target="RFC7541"/>.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<t><xref target="types"/> defines binary serialisations of Structured Headers types. <xref target="negotiate"/> shows how to negotiate their use in a HTTP/2 connection. <xref target="backport"/> shows how to use Structured Headers types with already defined header fields.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="types" title="Binary Structured Types">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</t>

<figure><artwork><![CDATA[
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
]]></artwork></figure>

<t>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</t>

<section anchor="list" title="Lists">

<t>The List data type (type=0x1) has a length field that indicates how many members are in the list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented by one or more Binary Structured Types (depending on their types), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>list-members that are Items are represented as per <xref target="item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>Binary Structured Headers can represent Lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x2) has a length field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented as an Item (<xref target="item"/>), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x3) has a length field that indicates how many (parameter-name, parameter-value) pairs are present, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Parameters...
--+--------+--------+---------
]]></artwork></figure>

<t>Each pair will be represented by at least two Binary Structured Types; the parameter-name, represented as a token (<xref target="token"/>), and the parameter-value, which is represented as a bare item (<xref target="item"/>).</t>

<t>If the parameters cannot be represented, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
</section>
<section anchor="dictionaries" title="Dictionaries">

<t>The Dictionary data type (type=0x4) has a length field that indicates how many members are in the dictionary, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Dictionary members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the dictionary will be represented by at least two Binary Structured Types; the member-name, represented as a token (<xref target="token"/>), and the member-value, which is represented as one or more Binary Structured Types as per their definitions.</t>

<t>member-values that are Items are represented as per <xref target="item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If the dictionary cannot be represented, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent Dictionaries with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="item" title="Items">

<t>Items are represented using one to many Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</t>

<t>The item’s parameters, if present, are serialised as the Parameter type (<xref target="parameter"/>), which will include zero or more following types.</t>

<t>Bare items are never serialised with parameters.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x5) has a payload of 58 bits:</t>

<figure><artwork><![CDATA[
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>X - 1 bit; discard</t>
  <t>Integer - 50 bits, unsigned</t>
  <t>Pad - 6 bits</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x6) have a payload of 74 bits:</t>

<figure><artwork><![CDATA[
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>Integer - 47 bits, unsigned</t>
  <t>Fractional - 20 bits, unsigned integer</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
]]></artwork></figure>

<t>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0xa) has a payload of two bits:</t>

<figure><artwork><![CDATA[
--+
BX|
--+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. The value of X is discarded.</t>

</section>
</section>
<section anchor="TFV" title="Textual Field Values">

<t>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</t>

<t>Its payload is two bytes of padding, followed by the octets of the field value:</t>

<figure><artwork><![CDATA[
--+--------+----
XX| Field Value...
--+--------+----
]]></artwork></figure>

<t>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</t>

<t>TODO: huffman coding?</t>

</section>
</section>
<section anchor="negotiate" title="Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>, and convey Binary Structured Headers in a frame type defined in <xref target="frame"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the encoding of Binary Structured Headers defined in <xref target="types"/>.</t>
  <t>The peer will process the BINHEADERS frames as defined in <xref target="frame"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into HEADERS frames (if the peer is HTTP/2) or a form it will understand (e.g., the textual representation of Structured Headers data types defined in <xref target="I-D.ietf-httpbis-header-structure"/>).</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="frame" title="The BINHEADERS Frame">

<t>When a peer has indicated that it supports this specification {#setting}, a sender can send Binary Structured Headers in the BINHEADERS Frame Type (0xTODO).</t>

<t>The BINHEADERS Frame Type behaves and is represented exactly as a HEADERS Frame type (<xref target="RFC7540"/>, Section 6.2), with one exception; the field values encoded in the Header Block Fragment as Literal Header Field representations are Binary Structured Headers.</t>

<t>This means that a BINHEADERS frame can be converted to a HEADERS frame by converting the field values to the string representations of the various Structured Headers Types, and Textual Field Values (<xref target="TFV"/>) to their string counterparts.</t>

<t>Conversely, a HEADERS frame can be converted to a BINHEADERS frame by encoding all of the Literal field values as Binary Structured Types. In this case, the header types used are informed by the implementations knowledge of the individual header field semantics; see <xref target="backport"/>. Those which it cannot (do to either lack of knowledge or an error) or does not wish to convert into Structured Headers are conveyed in BINHEADERS as Textual Field Values (<xref target="TFV"/>).</t>

<t>Field values are stored in the HPACK <xref target="RFC7541"/> dynamic table without Huffman encoding, although specific Binary Structured Types might specify the use of such encodings.</t>

<t>Note that BINHEADERS and HEADERS frames MAY be mixed on the same connection, depending on the requirements of the sender. Also, note that only the field values are encoded as Binary Structured Types; field names are encoded as they are in HPACK.</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>TODO: Accept and Content-Type media types use + in values.</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>TODO: explicitly convert Expires to an integer?</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values (<xref target="TFV"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='August' day='25' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-13.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
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
PAPDC04AAA==

-->

</rfc>

