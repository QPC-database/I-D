<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.2.12 -->

<!DOCTYPE rfc SYSTEM "../Tools/rfcbootstrap/rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-nottingham-best-00" category="std">

  <front>
    <title>Binary Encoding of Structured Types</title>

    <author initials="M." surname="Nottingham" fullname="Mark Nottingham">
      <organization>Fastly</organization>
      <address>
        <email>mnot@mnot.net</email>
        <uri>https://www.mnot.net/</uri>
      </address>
    </author>

    <date />

    <area>General</area>
    
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields as ASCII strings. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP defines a set of data types that new headers can use to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>



    </abstract>


    <note title="Note to Readers">


<t><spanx style="emph">RFC EDITOR: please remove this section before publication</spanx></t>

<t>The issues list for this draft can be found at <eref target="https://github.com/mnot/I-D/labels/best">https://github.com/mnot/I-D/labels/best</eref>.</t>

<t>The most recent (often, unpublished) draft is at <eref target="https://mnot.github.io/I-D/best/">https://mnot.github.io/I-D/best/</eref>.</t>

<t>Recent changes are listed at <eref target="https://github.com/mnot/I-D/commits/gh-pages/best">https://github.com/mnot/I-D/commits/gh-pages/best</eref>.</t>

<t>See also the draft’s current status in the IETF datatracker, at
<eref target="https://datatracker.ietf.org/doc/draft-nottingham-best/">https://datatracker.ietf.org/doc/draft-nottingham-best/</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>HTTP messages often pass through several systems – clients, intermediaries, servers, and subsystems of each – that parse and process their header and trailer fields. This repeated parsing (and often re-serialisation) adds latency and consumes CPU, energy, and other resources.</t>

<t>Structured Headers for HTTP <xref target="I-D.ietf-httpbis-header-structure"/> offers a set of data types that new headers can combine to express their semantics. This specification defines a binary serialisation of those types that is more efficient to process, along with a negotiation mechanism for its use in HTTP/2; specifically, in HPACK Literal Header Field Representations <xref target="RFC7541"/>.</t>

<t>It also defines how to use Structured Headers for many existing headers – thereby “backporting” them – when supported by two peers.</t>

<t>The primary goal of this specification are to reduce parsing overhead and associated costs, as compared to the textual representation of Structured Headers. A secondary goal is a smaller wire format, but that is not always met. An additional goal is to enable future work on more granular header compression mechanisms.</t>

<t><xref target="types"/> defines binary serialisations of Structured Headers types. <xref target="negotiate"/> shows how to negotiate their use in a HTTP/2 connection. <xref target="backport"/> shows how to use Structured Headers types with already defined header fields.</t>

<section anchor="notational-conventions" title="Notational Conventions">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”,
“RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as
described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as
shown here.</t>

</section>
</section>
<section anchor="types" title="Binary Structured Types">

<t>This section defines a binary serialisation for the Structured Header Types defined in <xref target="I-D.ietf-httpbis-header-structure"/>.</t>

<t>Every Binary Structured Type starts with a 6-bit type field that defines the format of its payload:</t>

<figure><artwork><![CDATA[
+------+--+--------
|T (6) | Payload (0...)
+------+--+--------
]]></artwork></figure>

<t>Some Binary Structured Types have variable lengths; in these cases, the payload MUST have padding appended to align it with the next byte boundary.</t>

<section anchor="list" title="Lists">

<t>The List data type (type=0x1) has a length field that indicates how many members are in the list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented by one or more Binary Structured Types (depending on their types), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>list-members that are Items are represented as per <xref target="item"/>; list-members that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>Binary Structured Headers can represent Lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<section anchor="inner-list" title="Inner Lists">

<t>The Inner List data type (type=0x2) has a length field that indicates how many members are in the inner-list, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  List members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the list will be represented as an Item (<xref target="item"/>), unless it cannot be represented; in these cases, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent inner lists with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="parameter" title="Parameters">

<t>The Parameters data type (type=0x3) has a length field that indicates how many (parameter-name, parameter-value) pairs are present, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Parameters...
--+--------+--------+---------
]]></artwork></figure>

<t>Each pair will be represented by at least two Binary Structured Types; the parameter-name, represented as a token (<xref target="token"/>), and the parameter-value, which is represented as a bare item (<xref target="item"/>).</t>

<t>If the parameters cannot be represented, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent up to 1024 parameters; fields containing more will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
</section>
<section anchor="dictionaries" title="Dictionaries">

<t>The Dictionary data type (type=0x4) has a length field that indicates how many members are in the dictionary, as an unsigned 10-bit integer.</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  Dictionary members...
--+--------+--------+---------
]]></artwork></figure>

<t>Each member of the dictionary will be represented by at least two Binary Structured Types; the member-name, represented as a token (<xref target="token"/>), and the member-value, which is represented as one or more Binary Structured Types as per their definitions.</t>

<t>member-values that are Items are represented as per <xref target="item"/>; member-values that are inner-lists are represented as per <xref target="inner-list"/>.</t>

<t>If the dictionary cannot be represented, the field value will be serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Binary Structured Headers can represent Dictionaries with up to 1024 members; fields containing more members will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="item" title="Items">

<t>Items are represented using one to many Binary Structured Types. The bare-item is serialised as the appropriate Binary Structured Type, as per below.</t>

<t>The item’s parameters, if present, are serialised as the Parameter type (<xref target="parameter"/>), which will include zero or more following types.</t>

<t>Bare items are never serialised with parameters.</t>

<section anchor="integers" title="Integers">

<t>The Integer data type (type=0x5) has a payload of 58 bits:</t>

<figure><artwork><![CDATA[
--+--------+--------+--------+--------+--------+--------+--+------+
SX|  Integer                                               |  Pad |
--+--------+--------+--------+--------+--------+--------+--+------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>X - 1 bit; discard</t>
  <t>Integer - 50 bits, unsigned</t>
  <t>Pad - 6 bits</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="floats" title="Floats">

<t>The Float data type (type=0x6) have a payload of 74 bits:</t>

<figure><artwork><![CDATA[
-+-+--------+--------+--------+--------+--------+------+
S|   Integer                                           |
-+-+--------+--------+--------+--------+--------+------+

+--+--------+--------+--------+
|    Fractional               |
+--+--------+--------+--------+
]]></artwork></figure>

<t>Its fields are:</t>

<t><list style="symbols">
  <t>S - sign bit; 0 is negative, 1 is positive</t>
  <t>Integer - 47 bits, unsigned</t>
  <t>Fractional - 20 bits, unsigned integer</t>
</list></t>

<t>TODO: varint?</t>

</section>
<section anchor="strings" title="Strings">

<t>The String data type (type=0x7) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+---------
Length (10)|  String...
--+--------+--------+---------
]]></artwork></figure>

<t>Binary Structured Headers can represent Strings up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="token" title="Tokens">

<t>The Token data type (type=0x8) has a payload whose length is indicated by its first ten bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+--------+--------------
Length (10)|  Token...
--+--------+--------+--------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Tokens up to 1024 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

<t>TODO: Huffman coding?</t>

</section>
<section anchor="byte-sequences" title="Byte Sequences">

<t>The Byte Sequence data type (type=0x9) has a payload whose length is indicated by its first 14 bits (as an unsigned integer):</t>

<figure><artwork><![CDATA[
--+--------+----+----+---------------------
Length (14)     |XXXX|  Byte Sequence...
--+--------+----+----+---------------------
]]></artwork></figure>

<t>Binary Structured Headers can represent Byte Sequences up to 16384 characters in length; fields containing longer values will need to be serialised as Textual Field Values (<xref target="TFV"/>).</t>

</section>
<section anchor="booleans" title="Booleans">

<t>The Boolean data type (type=0xa) has a payload of two bits:</t>

<figure><artwork><![CDATA[
--+
BX|
--+
]]></artwork></figure>

<t>If B is 0, the value is False; if B is 1, the value is True. The value of X is discarded.</t>

</section>
</section>
<section anchor="TFV" title="Textual Field Values">

<t>The Textual Field Value data type (type=0xb) indicates that the contents are a textual HTTP header value, rather than a Binary Structured Header. The value may or may not be a Structured Header.</t>

<t>Its payload is two bytes of padding, followed by the octets of the field value:</t>

<figure><artwork><![CDATA[
--+--------+----
XX| Field Value...
--+--------+----
]]></artwork></figure>

<t>Note that unlike other binary data types, Textual Field Values rely upon their context to convey their length. As a result, they cannot be used anywhere but as a top-level field value; their presence elsewhere MUST be considered an error.</t>

<t>TODO: huffman coding?</t>

</section>
</section>
<section anchor="negotiate" title="Negotiating and Using Binary Structured Headers in HTTP/2">

<t>When both peers on a connection support this specification, they can take advantage of that knowledge to serialise headers that they know to be Structured Headers (or compatible with them; see <xref target="backport"/>).</t>

<t>Peers advertise and discover this support using a HTTP/2 setting defined in <xref target="setting"/>; individual HEADERS frames opt into this format using a sigil byte defined in <xref target="indicator"/>.</t>

<section anchor="setting" title="Binary Structured Headers Setting">

<t>Advertising support for Binary Structured Headers is accomplished using a HTTP/2 setting, SETTINGS_BINARY_STRUCTURED_HEADERS (0xTODO).</t>

<t>Receiving SETTINGS_BINARY_STRUCTURED_HEADERS from a peer indicates that:</t>

<t><list style="numbers">
  <t>The peer supports the encoding of Binary Structured Headers defined in <xref target="types"/>.</t>
  <t>The peer will process HEADERS frames containing the HEADERS indicator as defined in <xref target="indicator"/>.</t>
  <t>When a downstream consumer does not likewise support that encoding, the peer will transform them into an encoding it does understand (typically, the textual Structured Headers defined in <xref target="I-D.ietf-httpbis-header-structure"/>) where necessary.</t>
  <t>The peer will likewise transform all fields defined as Aliased Fields (<xref target="aliased"/>) into their non-aliased forms as necessary.</t>
</list></t>

<t>The default value of SETTINGS_BINARY_STRUCTURED_HEADERS is 0. Future extensions to Structured Headers might use it to indicate support for new types.</t>

</section>
<section anchor="indicator" title="HEADERS Indicator">

<t>When a peer has indicated that it supports this specification {#setting}, a sender indicates that a given HEADERS frame is serialising all of the fields in a header block fragment (<xref target="RFC7540"/> Section 6.2) as Binary Structured Types by prefixing the header block fragment with the byte 0x80 (i.e., 10000000, which is an illegal indexed header field reference in HPACK <xref target="RFC7541"/>).</t>

<t>Such header block fragments will serialise all field values as Binary Structured Types (possibly using Textual Field Values (<xref target="TFV"/>)). These field values can be indexed in the dynamic table just as “normal” field values, although they may have to be converted to textual field values upon reuse, depending upon the capabilities of the peer at that time.</t>

<t>Binary Structured Types do not have Huffman encoding applied to them (except as specified in their definitions).</t>

</section>
</section>
<section anchor="backport" title="Using Binary Structured Headers with Existing Fields">

<t>Any header field can potentially be parsed as a Structured Header according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/> and serialised as a Binary Structured Header. However, many cannot, so optimistically parsing them can be expensive.</t>

<t>This section identifies fields that will usually succeed in <xref target="direct"/>, and those that can be mapped into Structured Headers by using an alias field name in <xref target="aliased"/>.</t>

<section anchor="direct" title="Directly Represented Fields">

<t>The following HTTP field names can have their values parsed as Structured Headers according to the algorithms in <xref target="I-D.ietf-httpbis-header-structure"/>, and thus can usually be serialised using the corresponding Binary Structured Types.</t>

<t>When one of these fields’ values cannot be represented using Structured Types, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t><list style="symbols">
  <t>Accept - List</t>
  <t>Accept-Encoding - List</t>
  <t>Accept-Language - List</t>
  <t>Accept-Patch - List</t>
  <t>Accept-Ranges - List</t>
  <t>Access-Control-Allow-Credentials - Item</t>
  <t>Access-Control-Allow-Headers - List</t>
  <t>Access-Control-Allow-Methods - List</t>
  <t>Access-Control-Allow-Origin - Item</t>
  <t>Access-Control-Max-Age - Item</t>
  <t>Access-Control-Request-Headers - List</t>
  <t>Access-Control-Request-Method - Item</t>
  <t>Age - Item</t>
  <t>Allow - List</t>
  <t>ALPN - List</t>
  <t>Alt-Svc - List</t>
  <t>Alt-Used - Item</t>
  <t>Cache-Control - Dictionary</t>
  <t>Content-Encoding - Item</t>
  <t>Content-Language - List</t>
  <t>Content-Length - Item</t>
  <t>Content-Type - Item</t>
  <t>Expect - Item</t>
  <t>Forwarded - List</t>
  <t>Host - Item</t>
  <t>Origin - Item</t>
  <t>Pragma - Dictionary</t>
  <t>Prefer - Dictionary</t>
  <t>Preference-Applied - Dictionary</t>
  <t>Retry-After - Item  (see caveat below)</t>
  <t>Surrogate-Control - Dictionary</t>
  <t>TE - List</t>
  <t>Trailer - List</t>
  <t>Transfer-Encoding - List</t>
  <t>Vary - List</t>
  <t>X-Content-Type-Options - Item</t>
</list></t>

<t>Note that only the delta-seconds form of Retry-After is supported; a Retry-After value containing a http-date will need to be either converted into delta-seconds or serialised as a Textual Field Value (<xref target="TFV"/>).</t>

<t>TODO: Accept and Content-Type media types use + in values.</t>

</section>
<section anchor="aliased" title="Aliased Fields">

<t>The following HTTP field names can have their values represented in Structured headers by mapping them into its data types and then serialising the resulting Structured Header using an alternative field name.</t>

<t>For example, the Date HTTP header field carries a http-date, which is a string representing a date:</t>

<figure><artwork><![CDATA[
Date: Sun, 06 Nov 1994 08:49:37 GMT
]]></artwork></figure>

<t>Its value is more efficiently represented as an integer number of delta seconds from the Unix epoch (00:00:00 UTC on 1 January 1970, minus leap seconds). Thus, the example above would be represented in (non-binary) Structured headers as:</t>

<figure><artwork><![CDATA[
SH-Date: 784072177
]]></artwork></figure>

<t>As with directly represented fields, if the intended value of an aliased field cannot be represented using Structured Types successfully, its value can instead be represented as a Textual Field Value (<xref target="TFV"/>).</t>

<t>Note that senders MUST know that the next-hop recipient understands these fields (typically, using the negotiation mechanism defined in <xref target="negotiate"/>) before using them. Likewise, recipients MUST transform them back to their unaliased form before forwarding the message to a peer or other consuming components that do not have this capability.</t>

<t>Each field name listed below indicates a replacement field name and a way to map its value to Structured Headers.</t>

<section anchor="urls" title="URLs">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by considering their payload a string.</t>

<t><list style="symbols">
  <t>Content-Location - SH-Content-Location</t>
  <t>Location - SH-Location</t>
  <t>Referer - SH-Referer</t>
</list></t>

<t>For example, a (non-binary) Location:</t>

<figure><artwork><![CDATA[
SH-Location: "https://example.com/foo"
]]></artwork></figure>

<t>TOOD: list of strings, one for each path segment, to allow better compression in the future?</t>

</section>
<section anchor="dates" title="Dates">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by parsing their payload according to <xref target="RFC7230"/>, Section 7.1.1.1, and representing the result as an integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, minus leap seconds).</t>

<t><list style="symbols">
  <t>Date - SH-Date</t>
  <t>Expires - SH-Expires</t>
  <t>If-Modified-Since - SH-IMS</t>
  <t>If-Unmodified-Since - SH-IUS</t>
  <t>Last-Modified - SH-LM</t>
</list></t>

<t>For example, a (non-binary) Expires:</t>

<figure><artwork><![CDATA[
SH-Expires: 1571965240
]]></artwork></figure>

</section>
<section anchor="etags" title="ETags">

<t>The following field names (paired with their replacement field names) have values that can be represented in Binary Structured Headers by representing the entity-tag as a string, and the weakness flag as a boolean “w” parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.</t>

<t><list style="symbols">
  <t>ETag - SH-ETag</t>
</list></t>

<t>For example, a (non-Binary) ETag:</t>

<figure><artwork><![CDATA[
SH-ETag: "abcdef"; w=?1
]]></artwork></figure>

<t>If-None-Match is a list of the structure described above.</t>

<t><list style="symbols">
  <t>If-None-Match - SH-INM</t>
</list></t>

<t>For example, a (non-binary) If-None-Match:</t>

<figure><artwork><![CDATA[
SH-INM: "abcdef"; w=?1, "ghijkl"
]]></artwork></figure>

</section>
<section anchor="links" title="Links">

<t>The field-value of the Link header field <xref target="RFC8288"/> can be represented in Binary Structured Headers by representing the URI-Reference as a string, and link-param as parameters.</t>

<t><list style="symbols">
  <t>Link: SH-Link</t>
</list></t>

<t>For example, a (non-binary) Link:</t>

<figure><artwork><![CDATA[
SH-Link: "/terms"; rel="copyright"; anchor="#foo"
]]></artwork></figure>

</section>
<section anchor="cookies" title="Cookies">

<t>The field-value of the Cookie and Set-Cookie fields <xref target="RFC6265"/> can be represented in Binary Structured Headers as a List with parameters and a Dictionary, respectively. The serialisation is almost identical, except that the Expires parameter is always a string (as it can contain a comma), multiple cookie-strings can appear in Set-Cookie, and cookie-pairs are delimited in Cookie by a comma, rather than a semicolon.</t>

<t>Set-Cookie: SH-Set-Cookie
Cookie: SH-Cookie</t>

<figure><artwork><![CDATA[
SH-Set-Cookie: lang=en-US, Expires="Wed, 09 Jun 2021 10:18:14 GMT"
SH-Cookie: SID=31d4d96e407aad42, lang=en-US
]]></artwork></figure>

<t>TODO: explicitly convert Expires to an integer?</t>

</section>
</section>
</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>TODO</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>As is so often the case, having alternative representations of data brings the potential for security weaknesses, when attackers exploit the differences between those representations and their handling.</t>

<t>One mitigation to this risk is the strictness of parsing for both non-binary and binary Structured Headers data types, along with the “escape valve” of Textual Field Values (<xref target="TFV"/>). Therefore, implementation divergence from this strictness can have security impact.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference  anchor="RFC2119" target='https://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference anchor="I-D.ietf-httpbis-header-structure">
<front>
<title>Structured Headers for HTTP</title>

<author initials='M' surname='Nottingham' fullname='Mark Nottingham'>
    <organization />
</author>

<author initials='P' surname='Kamp' fullname='Poul-Henning Kamp'>
    <organization />
</author>

<date month='August' day='25' year='2019' />

<abstract><t>This document describes a set of data types and associated algorithms that are intended to make it easier and safer to define and handle HTTP header fields.  It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP field values.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-httpbis-header-structure-13' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-httpbis-header-structure-13.txt' />
</reference>



<reference  anchor="RFC7541" target='https://www.rfc-editor.org/info/rfc7541'>
<front>
<title>HPACK: Header Compression for HTTP/2</title>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='H.' surname='Ruellan' fullname='H. Ruellan'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.</t></abstract>
</front>
<seriesInfo name='RFC' value='7541'/>
<seriesInfo name='DOI' value='10.17487/RFC7541'/>
</reference>



<reference  anchor="RFC8174" target='https://www.rfc-editor.org/info/rfc8174'>
<front>
<title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
<author initials='B.' surname='Leiba' fullname='B. Leiba'><organization /></author>
<date year='2017' month='May' />
<abstract><t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='8174'/>
<seriesInfo name='DOI' value='10.17487/RFC8174'/>
</reference>



<reference  anchor="RFC7540" target='https://www.rfc-editor.org/info/rfc7540'>
<front>
<title>Hypertext Transfer Protocol Version 2 (HTTP/2)</title>
<author initials='M.' surname='Belshe' fullname='M. Belshe'><organization /></author>
<author initials='R.' surname='Peon' fullname='R. Peon'><organization /></author>
<author initials='M.' surname='Thomson' fullname='M. Thomson' role='editor'><organization /></author>
<date year='2015' month='May' />
<abstract><t>This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection.  It also introduces unsolicited push of representations from servers to clients.</t><t>This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.</t></abstract>
</front>
<seriesInfo name='RFC' value='7540'/>
<seriesInfo name='DOI' value='10.17487/RFC7540'/>
</reference>



<reference  anchor="RFC7230" target='https://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference  anchor="RFC8288" target='https://www.rfc-editor.org/info/rfc8288'>
<front>
<title>Web Linking</title>
<author initials='M.' surname='Nottingham' fullname='M. Nottingham'><organization /></author>
<date year='2017' month='October' />
<abstract><t>This specification defines a model for the relationships between resources on the Web (&quot;links&quot;) and the type of those relationships (&quot;link relation types&quot;).</t><t>It also defines the serialisation of such links in HTTP headers with the Link header field.</t></abstract>
</front>
<seriesInfo name='RFC' value='8288'/>
<seriesInfo name='DOI' value='10.17487/RFC8288'/>
</reference>



<reference  anchor="RFC6265" target='https://www.rfc-editor.org/info/rfc6265'>
<front>
<title>HTTP State Management Mechanism</title>
<author initials='A.' surname='Barth' fullname='A. Barth'><organization /></author>
<date year='2011' month='April' />
<abstract><t>This document defines the HTTP Cookie and Set-Cookie header fields. These header fields can be used by HTTP servers to store state (called cookies) at HTTP user agents, letting the servers maintain a stateful session over the mostly stateless HTTP protocol.  Although cookies have many historical infelicities that degrade their security and privacy, the Cookie and Set-Cookie header fields are widely used on the Internet.  This document obsoletes RFC 2965.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6265'/>
<seriesInfo name='DOI' value='10.17487/RFC6265'/>
</reference>




    </references>




  </back>

<!-- ##markdown-source:
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
v7c8ykUBl5MqUgtAiqE1Vsae/0Lfbt7fD49/eXjYAmTipnxHCiIV0uOEPEK8
qu4TJpwBOu7vwVWIHx7esebBEpR55kfENuunKD4iUV3F2ceK01XMYJmReDaf
IR/3uju7jrbvXNQN9kRzmSCmiSIOREJSIowErCCrAVWqhquNDXTMAe5CJiq7
MJJRvm6Qj51vlY9yuX9BKTEAI2chUg0L/ZGc/1SWI6Sz6I9kPOK8S55xcAVx
uvuNmbuxfFd5ucp3L7+K7zaLuX1MALZZeU8I34IH0vKlxdE/gRvLDX0VLyJo
63Q0bBdzIppihzVK+p01oXUMLLMxUPEGAhIgEV0QH1M8XBtL2GqDdyUBMBMY
12cZkWjXBQKjqnF9ItUsGf/3klBh/BK4tbz/zcqWHUpyHSlvYdi8eLJoYPPd
b1WvYTH7P4GhK6B/u5ItIf12ZjczP4PT7cBH2PwpnpH1CoxLRE63dFnX6iJf
76CsGf0cD+VkBfPfiVRWpeSP84wsRcAlQtRjaqiJQLlJuZj8GYnhGpbAJJog
BemTgqRAsgoSYhnimSydZZRYaJ6n7cg5ElE6t6kinPAHVVFhbSbHFVOWLW9f
Vw2s1Tn396UJRqEw7E9olEkQ5aFgfxdZWrD+OI0AAty9SZcAfZ32N2hKMIVb
XZhIWQJZ+J+kgZRzN+muQRm+csrQhYOgOV69gdhbq/4TtNeXL1wM6w0+gWZz
QHzdH9n4kP36u8BBevIEpNmV3TIsGf7IBsxnqMFx3+9YlxJrYkIlxTbr4e0s
VRJv4eNP8HHPfBlKFfAshIducz571SXstQujAG9xBz57TS+AIheHF32K0hP9
kyHXMeBeW2LRdQOpXm+ZML1Gq73dGq1ePAtJQCBA8zMI9OvzV/RefPk7DyFi
x1jFNVm45ZUfG/+70Lok6+7eKlkr0PlsZ5nuzgtoJPjA1HkNxc1NA8n3lqVz
Ttl/67hIVTgsZMslbTZDYy5oe6B8l/wTC9LWU2R72TMxUD7VG3mqWbKIqBqj
YMoRsfgteFxms02WCUsbQBtrtb/RNBkafczH45jKN5h/sbQaoktDCUvybQzN
6GEDyd78oSRrohtB+jjZnkE7i5jvmHQfME85EP+biyRwwUHtWQMF3z6Tgr3d
ZxHwRQMZVggJMQtpvU/wByStbaGJtF+a9KtIXEegI/Xrl2/+IFobqqYpBC2u
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

-->

</rfc>

